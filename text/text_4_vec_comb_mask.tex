% Комбинирование векторных масок.
\subsection{Комбинирование векторных масок}

В общем случае можно считать, что в результате слияния под соответствующими предикатами ветвей исполнения внутри тела плоского цикла мы получим совокупность векторных блоков, обрабатывающихся сходим образом: загрузка входных данных \texttt{in\_data} под маской векторного блока, выполнение вычислений \texttt{block} под маской блока, сохранение результатов \texttt{out\_data} под маской блока (см. рис. 6).

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\textwidth]{./pics/text_4_vec_comb_mask/vec_block.pdf}
	\caption{Схема вычислений векторизованного блока команд с входными данными \texttt{in\_data}, выходными данные \texttt{out\_data} и маской исполнения \texttt{0xEA}.}
	\label{fig:text_4_vec_comb_mask_vec_block}
\end{figure}

Проверка маски блока на пустоту может повысить эффективность кода, если маски часто оказываются пустыми.
Однако этот никак не поможет в том случае, если в маске выставлено несколько битов.
В некоторых случаях достичь повышения производительности можно путем объединения двух соседних векторных блоков.
Рассмотрим простейший случай такого объединения.
Если у нас есть два соседних векторных блока \texttt{in\_data\_1} $\rightarrow$ \texttt{block} $\rightarrow$ \texttt{out\_data\_1} и \texttt{in\_data\_2} $\rightarrow$ \texttt{block} $\rightarrow$ \texttt{out\_data\_2}, которые должны выполняться под разными векторными масками \texttt{mask\_1} и \texttt{mask\_2}, и в дополнение к этому для этих масок выполнено условие \texttt{(mask\_1 \& mask\_2) == 0x0}, то вычисление этих двух соседних блоков можно объединить.
Вместо последовательного выполнения двух векторных блоков можно объединить входные данные с помощью слияния векторов по условию \texttt{in\_data = \_mm512\_mask\_blend\_ps(mask\_1, in\_data\_2, in\_data\_1}), после чего выполнить тот же блок вычислений под маской \texttt{mask\_1 | mask\_2}.
Ввиду отсутствия пересечения векторных масок в результирующем выходном векторе \texttt{out\_data} будут содержаться как необходимые элементы вектора \texttt{out\_data\_1}, так и необходимые элементы вектора \texttt{out\_data\_2}.
Последним действием, которое нужно выполнить является извлечение из объединенного результата \texttt{out\_data} векторов \texttt{out\_data\_1} и \texttt{out\_data\_2} (см. рис. 7).
В результате такого преобразования в случае отсутствия пересечения векторных масок количество вычислений рассматриваемого блока \texttt{block} сокращается вдвое, а плотность векторных масок внутри блока повышается.
Однако вместе с этим появляются накладные расходы, связанные с проверками масок, а также операции слияния векторов до вычислений блока и выделения нужных данных после вычислений.
Заметим, что эту технику можно применять для объединения трех и более соседних блоков, однако это связано с еще большим возрастанием накладных расходов.

\begin{figure}[ht]
	\centering
		\includegraphics[width=1.0\textwidth]{./pics/text_4_vec_comb_mask/comb_masks.pdf}
	\caption{Схема вычислений с объединением двух векторизованных блоков \texttt{in\_data\_1} $\rightarrow$ \texttt{block} $\rightarrow$ \texttt{out\_data\_1}, \texttt{in\_data\_2} $\rightarrow$ \texttt{block} $\rightarrow$ \texttt{out\_data\_2}. Объединение допустимо, так как векторные маски \texttt{0xCC00} и \texttt{0xEA} не пересекаются, объединенный блок выполняется под маской \texttt{0xCCEA}.}
	\label{fig:text_4_vec_comb_mask_comb_masks}
\end{figure}

Еще один подход, о котором стоит упомянуть, но который не тестировался в рамках данной работы, связан с объединением соседних блоков, для которых \texttt{(mask\_1 \& mask\_2) != 0x0}.
Если мы имеем дело с двумя масками низкой плотности, которые пересекаются, но для которых выполнено условие \texttt{popcnt(mask\_1) + popcnt(mask\_2) <= w}, то такие блоки также можно объединить.
Для этого необходимо найти такое преобразование одной из масок (например, \texttt{mask\_1}) \texttt{perm\_to}, что оно будет иметь обратное преобразование \texttt{perm\_from(perm\_to(mask\_1)) == mask\_1} и будет выполнено условие \texttt{(perm\_to(mask\_1) \& mask\_2) == 0x0}.
В этом случае элементы входных данных переставляются местами в соответствии с преобразованием \texttt{perm\_to}, применяется описанная выше техника объединения блоков, а для выходных данных выполняется перестановка элементов в соответствии с преобразованием \texttt{perm\_from} (см. рис. 8).

\begin{figure}[ht]
	\centering
		\includegraphics[width=1.0\textwidth]{./pics/text_4_vec_comb_mask/comb_masks_perm.pdf}
	\caption{Схема вычислений с объединением двух векторизованных блоков при условии пересечения их масок. Для объединения применяется техника изменения порядка элементов в данных одного из блоков.}
	\label{fig:text_4_vec_comb_mask_comb_masks_perm}
\end{figure}

В описанном подходе следует отметить следующие моменты.
Во-первых, объединять можно не только два соседние блока, но также три и более, хотя это существенно усложняет программный код и увеличивает количество накладных расходов.
Во вторых, следует принимать во внимание доступные операции по изменению порядка расположения элементов векторов, так как таких операций достаточно много и они отличаются по времени выполнения (SHUF, UNPCK, VPERM, VPERMIL).

\subsubsection{Практическое применение проверки и комбинирования масок для векторизация функции \texttt{prefun} из реализации римановского решателя}

В качестве примера, на котором мы будем проводить анализ методов повышения эффективности векторизации кода с условиями, возьмем одну из функций реализации газодинамического решателя -- функцию \texttt{prefun}.
Для удобства будем пользоваться реализацией данной функции на языке программирования C, как это представлено на листинге 1 (исходный код функции доступен в открытом репозитории ).

\begin{lstlisting}[caption={caption},label={label}]
void scase_prefun_1(float& f,
                    float& fd,
                    float p,
                    float dk,
                    float pk,
                    float ck)
{
    if (p <= pk)
    {
        float prat = p / pk;
        f = riemann::sg4 * ck * (pow(prat, riemann::sg1) - 1.0f);
        fd = (1.0f / (dk * ck)) * pow(prat, -riemann::sg2);
    }
    else
    {
        float ak = riemann::sg5 / dk;
        float bk = riemann::sg6 * pk;
        float qrt = sqrt(ak / (bk + p));
        f = (p - pk) * qrt;
        fd = (1.0f - 0.5f * (p - pk) / (bk + p)) * qrt;
    }
}
\end{lstlisting}

В данном листинге мы видим реализацию функции prefun, обрабатывающей один набор скалярных данных.
Функция принимает на входные аргументы \texttt{p}, \texttt{dk}, \texttt{pk}, \texttt{ck} и вычисляет выходные аргументы \texttt{f}, \texttt{fd}.
Функция содержит одно условие в зависимости от которого выходные аргументы вычисляются с помощью той или иной последовательности операций.
Все задействованные в реализации функции операции имеют векторные аналоги в наборе инструкций AVX-512 (точнее в наборе функций-интринсиков), поэтому приведенная функция может быть векторизована путем замены скалярных операций векторными аналогами и слияния ветвей исполнения под соответствующими предикатами, как это показано на листинге 2.
В процессе векторизации умышленно не применялись никакие локальные оптимизации, все скалярные операции были строго заменены на векторные аналоги с сохранением порядка вычислений с точности до ассоциативности умножения.
Для удобства код, относящийся к блокам \texttt{block A} и \texttt{block B}, заключен в фигурные скобки.

\begin{lstlisting}[caption={caption},label={label}]
void vcase_prefun_1(__m512& f,
                    __m512& fd,
                    __m512& p,
                    __m512& dk,
                    __m512& pk,
                    __m512& ck,
                    __mmask16 m)
{
    __mmask16 cond = _mm512_kand(_mm512_cmple_ps_mask(p, pk), m);
    __mmask16 ncond = _mm512_kand(_mm512_knot(cond), m);

    { // first branch
        __m512 prat = _mm512_mask_div_ps(zero, cond, p, pk);

        f = _mm512_mask_mul_ps(f, cond,
                _mm512_mask_mul_ps(zero, cond, riemann::g4, ck),
                _mm512_mask_sub_ps(zero, cond,
                    _mm512_mask_pow_ps(zero, cond, prat, riemann::g1),
                    one));

        fd = _mm512_mask_mul_ps(fd, cond,
                 _mm512_mask_div_ps(zero, cond,
                     one,
                     _mm512_mask_mul_ps(zero, cond, dk, ck)),
_mm512_mask_pow_ps(zero, cond,
                     prat,
                     _mm512_mask_sub_ps(zero, cond, zero, riemann::g2)));
    }

    { // second branch
        __m512 ak = _mm512_mask_div_ps(zero, ncond, riemann::g5, dk);
        __m512 bk = _mm512_mask_mul_ps(zero, ncond, riemann::g6, pk);
        __m512 qrt = _mm512_mask_sqrt_ps(zero, ncond,
                         _mm512_mask_div_ps(zero, ncond,
                             ak,
                             _mm512_mask_add_ps(zero, ncond, bk, p)));

        f = _mm512_mask_mul_ps(f, ncond,
                _mm512_mask_sub_ps(zero, ncond, p, pk),
                qrt);

        fd = _mm512_mask_mul_ps(fd, ncond,
                 _mm512_mask_sub_ps(zero, ncond,
                     one,
                     _mm512_mask_mul_ps(zero, ncond,
                         half,
                         _mm512_mask_div_ps(zero, ncond,
                             _mm512_mask_sub_ps(zero, ncond, p, pk),
                             _mm512_mask_add_ps(zero, ncond, bk, p)))),
                 qrt);
    }
}                 
\end{lstlisting}

Сравнивая листинги 1 и 2, содержащие скалярный и векторный код, можно установить соответствие между участвующими в них объектами, как это показано в таблице 1.

\begin{center}
\begin{tabular}{ | c | c | }
  \hline
  Объект скалярной версии \texttt{scase\_prefun\_1} & Объект векторной версии \texttt{vcase\_prefun\_1} \\ \hline\hline
  \makecell{скалярные аргументы \texttt{float f}, \texttt{fd}, \texttt{p}, \texttt{dk} и т.д.} & \makecell{векторные аргументы \texttt{\_\_m512 f}, \texttt{fd}, \texttt{p}, \texttt{dk} и т.д.} \\ \hline
  \makecell{скалярные глобальные данные \texttt{riemann::sg1}, \texttt{riemann::sg2} и т.д.} & \makecell{векторные глобальные данные \texttt{riemann::g1}, \texttt{riemann::g2}} \\ \hline
  \makecell{скалярные операции \texttt{+}, \texttt{-}, \texttt{*}, \texttt{\/}, \texttt{pow}} & \makecell{векторные команды, заданные функциями-интринсиками \texttt{\_mm512\_mask\_add\_ps}, \texttt{\_mm512\_mask\_sub\_ps}, \texttt{\_mm512\_mask\_mul\_ps}, \texttt{\_mm512\_mask\_div\_ps}, \texttt{\_mm512\_mask\_pow\_ps}} \\ \hline
  \makecell{скалярная операция сравнения \texttt{<=}} & \makecell{векторные операции получения масок \texttt{\_mm512\_cmple\_ps\_mask}, \texttt{\_mm512\_knot}, \texttt{\_mm512\_kand}} \\ \hline
\end{tabular}
\end{center}

Из приведенного листинга 2 векторного кода видно, что часть команд выполняется с использованием векторной маски \texttt{cond}, тогда как другая часть команд использует векторную маску \texttt{ncond}.
При этом понятно, что если маска cond окажется нулевой, то нет необходимости выполнять инструкции, использующие эту маску.
То же касается маски \texttt{ncond}.
Для того, чтобы учесть это изменение достаточно перед выполнением блока операций, относящихся к \texttt{block A}, проверить маску cond на пустоту, в противном случае вообще не выполнять соответствующие инструкции.
Аналогично следует поступить с маской ncond. 

Когда мы вычисляли вероятность появления пустой маски, то принимали условное соглашение, что выполнение условий для разных наборов скалярных данных являются независимыми событиями.
На самом деле это не так и существенным образом зависит от локальности размещения данных, участвующих в расчетах [21].
Рассмотрим более подробно наше условие \texttt{p <= pk}.
Элементы данных \texttt{p} и \texttt{pk}, свои для каждой расчетной ячейки.
Если речь идет о физических расчетах (а функция prefun относится к газодинамическому решателю), то значение элемента данных изменяется не слишком сильно при переходе от одной ячейки к соседней ячейке.
Из этого следует, что и значение условия \texttt{p <= pk} при переходе от одной ячейке к соседней будет изменяться также не слишком быстро.
Но условие это дискретная величина, а это значит, что часто значение условия будет сохраняться при переходе к соседней ячейке.
Рассмотри теоретический краевой случай, когда во время обработки $n$ наборов скалярных данных условие выполняется для первых $np$ из них и не выполняется для оставшихся $n(1 - p)$.
Для простоты будем считать, что все числа $np$, $n(1 - p$, кратны ширине векторизации $w$.
В этом случае очевидно, что во время выполнения векторной версии кода первые $\frac{np}{w}$ масок cond будут полные, а остальные $\frac{n(1 - p)}{w}$ масок cond будут пустыми (с масками \texttt{ncond} ситуация будет обратной).
В таком случае, время исполнения векторизованной версии кода с проверкой обеих масок cond и ncond на пустоту в точности совпадет со временем $T_1$.
Таким образом, эффективность векторизации в этом теоретически идеальном случае будет ровно единица с поправкой на дополнительные операции проверки масок на пустоту.

Для рассматриваемой функции \texttt{prefun} были собраны расчетные данные распределения плотности маски условия \texttt{p <= pk}, чтобы оценить вероятность появления пустых масок \texttt{cond} и \texttt{ncond}.
На рис. 4 представлено распределение плотности масок в случае независимости условий для разных наборов скалярных данных (нетрудно видеть, что распределение является нормальным).
Результаты распределения плотности маски cond, собранные по настоящему профилю исполнения векторного кода на реальных данных, представлены на рис. 5.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\textwidth]{./pics/text_4_vec_comb_mask/independent_p.png}
	\caption{Гистограмма распределения плотностей маски \texttt{cond} при условии, что все условия \texttt{p <= pk} для наборов скалярных данных являются независимыми.}
	\label{fig:text_4_vec_comb_mask_independent_p}
\end{figure}

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\textwidth]{./pics/text_4_vec_comb_mask/real_p.png}
	\caption{Гистограмма распределения плотностей маски \texttt{cond} на реальном профиле исполнения.}
	\label{fig:text_4_vec_comb_mask_real_p}
\end{figure}

Из рис. 4 и рис. 5 видно, что распределение плотностей масок на реальных данных совершенно не похоже на распределение, вычисленное в предположении о независимости условий переходов.
Можно заметить, что в реальном коде более четверти всех масок \texttt{cond} являются либо пустыми, либо полными (в этом случае пустой является маска \texttt{ncond}), а значит использование проверок масок на пустоту обосновано.

Для анализа полученных результатов были рассмотрены следующие три подхода к векторизации плоского цикла с условием.
В качестве базового метода векторизация принималось простое слияние путей исполнения под соответствующими предикатами с последующим объединением $w$ последовательных скалярных итераций в одну векторную (простое слияние).
Данный базовый метод сравнивался с двумя рассмотренными выше улучшениями: проверка масок блоков на пустоту (проверка масок) и слияние двух соседних блоков при условии отсутствия пересечения их масок (комбинирование масок).
Анализ эффективности применения преобразований рассматривался на приведенной в листинге 1 функции \texttt{prefun} из реализации газодинамического римановского решателя.
Профиль исполнения функции собирался на задачах моделирования распада разрыва при различных начальных условиях [22,23].
Собранный профиль исполнения функций римановского решателя доступен в открытом репозитории.
Эффективность векторизации при выбранных подходах измерялась двумя способами. В качестве первого способа использовался режим эмуляции векторных инструкций.
В настоящее время используются различные эмуляторы AVX-512 с помощью которых можно оценить эффективность векторного кода [24].
В данной работе мы ограничились инструментом, позволяющим отследить плотность используемых в коде масок и общее количество скалярных и векторных операций [25].
Вторым способом сравнения был замер производительности результирующего векторного кода на микропроцессоре Intel Xeon Phi Knights Landing 7290.
Результаты сравнения представлены на рис. 9.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.8\textwidth]{./pics/text_4_vec_comb_mask/res.png}
	\caption{Результаты сравнения эффективности векторизации при простом слиянии, с проверкой масок и с комбинированием масок в режимах эмуляции и на микропроцессоре Intel Xeon Phi Knights Landing 7290.}
	\label{fig:text_4_vec_comb_mask_res}
\end{figure}

Эксперименты показали, что в режиме эмуляции слияние ветвей исполнения привело к эффективности векторизации 0.6.
Использование дополнительных методов повышения плотности векторных масок в коде -- проверки масок и комбинирования масок -- привело к повышению эффективности векторизации до показателей 0.67 и 0.75 соответственно.
Эффективность векторизации при проведении замеров на реальной машине оказалась скромнее.
Простое слияние путей исполнения позволило достичь эффективности 0.31, а использование проверок масок и комбинирования масок позволило повысить эффективность векторизации до 0.43 и 0.47 соответственно.
