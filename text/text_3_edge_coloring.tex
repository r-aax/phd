% Реберная раскраска кубического графа для устранения конфликтов при проведении вычислений на неструктурированной поверхностной расчетной сетке.
\subsection{Реберная раскраска кубического графа для устранения конфликтов при проведении вычислений на неструктурированной поверхностной расчетной сетке}

Моделирование процесса обледенения поверхности тела выполняется итерационно.
На каждой итерации расчетов в каждой расчетной ячейке производится решение системы уравнений массового и теплового балансов, из которой получаются основные данные состояния расчетной ячейки (температура, количество жидкой воды и накопленного льда).
Между расчетными итерациями выполняется моделирование протекания потоков жидкости между соседними ячейками (потоки массы и тепла через границы ячеек) [10-12].
Также в зависимости от настроек решателя через заданные промежутки времени выполняется пересчет геометрии поверхности тела за счет накопленной в ее ячейках массы льда.
Будем считать, что расчеты обледенения выполняются на неструктурированной поверхностной расчетной сетке с треугольными ячейками.
Пересчет состояния ячейки выполняется независимо от других ячеек, данные вычисления могут выполняться параллельно.
Пересчет потоков массы и тепла выполняются для каждого ребра домена расчетной сетки, при этом поток перетекает из одной инцидентной ребру ячейки в другую.
Общая схема пересчета потоков для одного ребра может выглядеть так, как представлено на листинге 1.

\begin{lstlisting}[caption={caption}, label={label}]
void Edge::calc_flows()
{
    // cells pair
    Cell* fst = ...;
    Cell* sec = ...;

    // flows calculation
    double flow_w = ...;
    double flow_q = ...;

    // flows correction
    fst->flow_out_w += flow_w;
    fst->flow_out_q += flow_q;
    sec->flow_out_w -= flow_w;
    sec->flow_out_q -= flow_q;
}
\end{lstlisting}

Для выполнения пересчета потоков для всех ребер домена расчетной сетки необходимо обработать все ребра в цикле (см. листинг 2).

\begin{lstlisting}[caption={caption}, label={label}]
for (auto e : own_edges)
{
    e->calc_flows();
}
\end{lstlisting}

При обработке ребер домена расчетной сетки в цикле возникает желание распараллелить или векторизовать данный цикл.
При распараллеливании вычислений с помощью OpenMP следует учитывать конфликты по данным, которые могут возникнуть при выполнении корректировки потоков (в случае если несколько потоков начнут одновременно изменять значение одной области памяти).
Для устранения этих конфликтов достаточно выполнять операции корректировки потоков в атомарном режиме, как показано на листинге 3.

\begin{lstlisting}[caption={caption}, label={label}]
#pragma omp atomic
fst->flow_out_w += flow_w;
#pragma omp atomic
fst->flow_out_q += flow_q;
#pragma omp atomic
sec->flow_out_w -= flow_w;
#pragma omp atomic
sec->flow_out_q -= flow_q;
\end{lstlisting}

Использование \texttt{\#pragma omp atomic} гарантирует, что указанная команда одновременно будет обрабатываться только одним потоком (то есть, что между чтением старого значения переменной и записью нового значения не вклинится другой поток).
При большом количестве используемых потоков это может приводить к потерям производительности. Следует отдельно отметить, что такой подход не сработает при попытке векторизации рассматриваемого цикла.
Зачастую вычисление самих потоков через ребро не содержит сложного управления, и может быть легко векторизовано, но векторизации всего цикла мешают зависимости по данным при корректировке потоков.
Возникает желание разбить исходное множество ребер сетки на такие подмножества, чтобы параллельная обработка ребер каждого отдельного подмножества не приводила к возникновению конфликтов при корректировке потоков.

\subsubsection{Сведение задачи распараллеливания вычислений к реберной раскраске}

Будем решать задачу разрешения конфликтов между ребрами расчетной сетки с помощью реберной раскраски графа конфликтов.
Такой подход является достаточно естественным [13], однако в нашем случае вершины графа конфликтов будут иметь небольшую степень, что свидетельствует о допустимости реберной раскраски в небольшое количество цветов.

Рассмотрим ситуацию, при которой возможно возникновение конфликта при корректировке потоков во время параллельной обработки двух ребер расчетной сетки.
Такой конфликт возможен в том случае, когда оба обрабатываемых ребра являются инцидентными одной и той же ячейке.
Рассмотрим дуальный граф нашей расчетной сетки – то есть граф, вершины которого соответствуют ячейкам расчетной сетки, а ребро проведено между двумя вершинами в том и только том случае, когда две соответствующие ячейки расчетной сетки являются соседними по ребру.
Без ограничения общности будем считать, что рассматриваемая расчетная сетка не имеет краев, то есть каждая ее ячейка имеет ровно трех соседей.
В этом случае ее дуальный граф будет кубическим.
При этом задача разбиения ребер расчетной сетки на неконфликтующие множества сводится к построению реберной раскраски дуального графа.
В процессе нахождения реберной раскраски построенного дуального графа зададимся вопросом, вызывающим  исследовательский интерес – в какое минимальное количество цветов можно раскрасить этот граф.

Следует сразу отметить, что ребра произвольного кубического графа можно тривиальным способом раскрасить в 5 цветов, так как у любого ребра есть ровно 4 смежных ребра, которые должны отличаться от него по цвету, поэтому для него всегда можно выбрать 5-й цвет.
Данный алгоритм является линейным, и интереса не представляет.
С другой стороны, очевидно, что двумя цветами обойтись не удастся, так как в каждой вершине сходятся по три разноцветных ребра.
Если кубический граф допускает правильную реберную раскраску в 3 цвета, то такая раскраска называется раскраской Тейта.
Заметим, что не все кубические графы допускают раскраску Тейта.
В работе [14] авторы предлагают способ построения раскраски Тейта для плоских кубических графов, который мы будем использовать в качестве основы.
Кубический граф, порожденный поверхностной расчетной сеткой, не всегда является плоским, но попытка поиска для него раскраски Тейта может быть оправдана.
К тому же для целей практического использования не будет большой проблемой отсутствие раскраски Тейта, в этом случае всегда можно воспользоваться тривиальной раскраской в 5 цветов.

\subsubsection{Редуцирование кубического графа по ребру и его восстановление}

Рассмотрим принцип и реализацию алгоритма построения раскраски Тейта для кубического графа, являющегося дуальным графом для замкнутой поверхностной неструктурированной расчетной сетки.
В работах [14,15] рассматривается подход к построению раскраски Тейта путем удаления ребер из исходного плоского кубического графа.
Ребра удаляются по тех пор, пока не будет получен кубический граф с уже известной раскраской.
После этого ребра возвращаются в граф в обратном порядке с соответствующей коррекцией раскраски. Операцию удаления ребра из графа будем называть редуцированием кубического графа по ребру.
Для того чтобы редуцирование кубического графа по ребру можно было использовать для построения раскраски Тейта, необходимо уметь провести последовательность редукций до достижения простого по структуре кубического графа, раскраска которого не представляет сложности.
При этом, в получающихся графах допустимо наличие параллельных ребер, однако запрещено появление петель, так как раскраска Тейта для кубического графа с петлями невозможна. Рассмотрим операцию редуцирования графа более подробно.

Сначала рассмотрим выполнение редуцирования кубического графа по ребру e с концами v1 и v2, где инцидентными ребрами вершины v1 являются ребра e, e1(v1), e2(v1), а инцидентными ребрами вершины v2 являются ребра e, e1(v2), e2(v2), а также среди ребер e, e1(v1), e2(v1), e1(v2), e2(v2) нет параллельных (см. рис. 1, слева).
Из этого следует, что существует только одно ребро, соединяющее вершины v1 и v2. В этом случае будем говорить, что редуцирование выполняется по уникальному ребру e.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/1-pic-reduce-edge-type-1.pdf}
\singlespacing
\captionstyle{center}\caption{Редуцирование по уникальному ребру.}
\label{fig:text_3_edge_coloring_1}
\end{figure}

При выполнении редуцирования по ребру e само ребро e удаляется, также удаляются вершины v1 и v2, ребра e1(v1) и e2(v1) склеиваются в результирующее ребро re1, ребра e1(v2) и e2(v2) склеиваются в ребро re2 (см. рис. 1, справа).

Другим случаем редуцирования является вариант, при котором также концами рассматриваемого ребра e являются вершины v1 и v2, однако между ними проходит еще одно ребро, без ограничения общности будем считать, что это ребро e2(v1) = e2(v2) (см. рис. 2, слева).
В этом случае при редуцировании удаляется ребро e, удаляются вершины v1 и v2, а все три ребра e1(v1), e2(v1) = e2(v2), e1(v2) склеиваются в единое ребро re1 = re2 (см. рис. 2, справа).
Такой шаг редуцирования будем называть редуцированием по параллельному ребру.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/2-pic-reduce-edge-type-2.pdf}
\singlespacing
\captionstyle{center}\caption{Редуцирование по параллельному ребру.}
\label{fig:text_3_edge_coloring_2}
\end{figure}

Отдельно отметим случай, когда между двумя вершинами проходит три параллельных ребра. Если мы достигли такого графа, то это и есть минимальный кубический граф, построение раскраски для которого очевидно, и от которого нужно двигаться в обратную сторону, постепенно восстанавливая исходный граф.
Также следует рассмотреть случай, при котором после редуцирования по уникальному ребру граф перестает быть связным.
Это значит, что в исходном графе ребро e было мостом, такие графы рассматривать не будем. В других случаях в графе найдется либо уникальное, либо параллельное ребро, по которому можно осуществить следующий шаг редуцирования.

В качестве примера рассмотрим редуцирование графа, представляющего собой куб, как показано на рис. 3.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/3-reduce-0.pdf}
\singlespacing
\captionstyle{center}\caption{Полное редуцирование графа.}
\label{fig:text_3_edge_coloring_3}
\end{figure}

На рис. 3 представлен кубический граф, содержащий 8 вершин v0 – v7 и 12 ребер e0 – e11. Будем считать, что нижние индексы в именах вершин и ребер являются также их идентификаторами.
Для полного редуцирования указанного графа требуется выполнение 3 шагов, которые могут быть записаны в историю редуцирования следующим образом:

e0 [(v0 : e3, e8 -> re12), (v1 : e1, e9 -> re13)]
e2 [(v2 : e13, e10 -> re14), (v3 : e12, e11 -> re15)]
e5 [(v5 : e4, e14 -> re16), (v6 : e6, e14 -> re16)]

По такой записи истории редуцирования можно идентифицировать каждый шаг, определить его тип (редуцирование по уникальному ребру или по параллельному) и выполнить восстановление графа.

Опираясь на указанные операции редуцирования можно описать алгоритм построения раскраски Тейта во время восстановления графа.

\subsubsection{Алгоритм реберной раскраски кубического графа в 3 цвета}

Прежде чем перейти к описанию алгоритма построения раскраски, рассмотрим центральный объект, который будет использован в данном построении. Без ограничения общности будем считать, что раскраска выполняется в следующие цвета: красный, синий и зеленый, – эти же цвета будем приводить на иллюстрациях.
Путь ребра некоторого кубического графа правильным образом раскрашены в три цвета.
Рассмотрим произвольные два цвета – например, красный и синий.
Если рассмотреть все ребра, покрашенные в эти два цвета, а также все инцидентные им вершины, то получим граф порядка 2, у которого в каждой вершине сходятся разноцветные ребра. Очевидно, такой граф является объединением простых циклов четной длины (двухцветных циклов).
На рис. 4 приведен пример такого двухцветного красно-синего цикла.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/4-bicolor-cycle.pdf}
\singlespacing
\captionstyle{center}\caption{Полная замена цветов в двухцветном цикле.}
\label{fig:text_3_edge_coloring_4}
\end{figure}

С таким двухцветным циклом можно выполнять следующие операции.
Во-первых, для всех ребер двухцветного цикла можно заменить цвет на противоположный, после чего раскраска в исходном графе останется правильной (см. рис. 4).
Также можно применить перекраску в противоположный цвет не всех ребер цикла, а только расположенных между двумя фиксированными ребрами e1 и e2 (на рис. 5 приведены два варианта такой перекраски в порядке обхода цикла по часовой и против часовой стрелки).
При такой перекраске ребер в цикле возникает два конфликта по цветам: между ребрами e1 и e2 и их перекрашенными соседями.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/5-bicolor-cycle-partial-switch.pdf}
\singlespacing
\captionstyle{center}\caption{Частичная замена цветов в двухцветном цикле.}
\label{fig:text_3_edge_coloring_5}
\end{figure}

Смысл частичной замены цветов в двухцветном цикле становится понятным, если возникает необходимость поместить в граф новое ребро.
На рис. 6 продемонстрирована операция, при которой выполняется частичная перекраска цикла между ребрами e1 и e2, а затем на ребра e1 и e2 добавляются новые вершины v1 и v2 соответственно, между которыми проводится ребро.
В завершение полученные после разбиения ребер e1 и e2 более мелкие ребра перекрашиваются для устранения конфликтов.
Новое проведенное ребро при этом перекрашивается в третий свободный цвет, что приводит к сохранению правильной раскраски во всем графе.
Таким образом, выбрав два произвольных ребра на любом двухцветном цикле, мы можем добавить новое ребро с концами на выбранных ребрах, а затем перекрасить ребра и сохранить правильную реберную раскраску.
Такую операцию будем называть восстановлением ребра по двухцветному циклу.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/6-bicolor-cycle-new-edge.pdf}
\singlespacing
\captionstyle{center}\caption{Замена цветов в двухцветном цикле при добавлении нового ребра.}
\label{fig:text_3_edge_coloring_6}
\end{figure}

Также нам понадобится операция поиска двухцветного цикла, начиная с произвольного ребра e, и содержащего ребра цветов color(e) и color2 != color(e). Такой цикл всегда существует и он ровно один.

Теперь, имея в своем распоряжении три простые операции: поиск двухцветного цикла по ребру и второму цвету, перекраска двухцветного цикла и восстановление ребра по двухцветному циклу, – мы можем описать алгоритм восстановления одного шага редуцирования графа с сохранением правильной реберной раскраски (см. рис. 7).

Дополнительно отметим, что восстановление шага редуцирования графа по параллельному ребру не представляет сложности, так как это локальная операция, которая затрагивает единственное результирующее ребро. Поэтому рассмотрим подробно только восстановление шага редуцирования по уникальному ребру.

Пусть мы имеем шаг редуцирования графа, результирующими ребрами после выполнения которого являются различные ребра re1 и re2.
В процессе восстановления мы должны поместить на эти ребра новые вершины v1 и v2 соответственно, провести между ними ребро и выполнить коррекцию раскраски. Опишем последовательность действий в данном случае.

Вариант 1. Если результирующие ребра re1 и re2 имеют разные цвета, то найдем двухцветный цикл, начиная с ребра re1, включающий в себя ребра цветов color(re1) и color(re2).
Если найденный цикл содержит также и ребро re2, то можно выполнить восстановление исходного ребра по найденному двухцветному циклу. В противном случае перекрасим найденный двухцветный цикл.
Так как перекрашивание затронет только ребро re1, то после этой операции мы получим ситуацию, в которой ребра re1 и re2 имеют один цвет. В этом случае переходим ко второму варианту.

\begin{figure}[ht]
\centering
\includegraphics[width=1.0\textwidth]{./pics/text_3_edge_coloring/7-algorithm.pdf}
\singlespacing
\captionstyle{center}\caption{Итерация алгоритма восстановления и перекраски графа.}
\label{fig:text_3_edge_coloring_7}
\end{figure}

Вариант 2. Если результирующие ребра re1 и re2 имеют один и тот же цвет, то рассмотрим два оставшихся цвета: x и y.
Рассмотрим два двухцветных цикла, начиная с ребра re1.
Причем в первый цикл будем включать ребра с цветами color(re1) и x, а во второй цикл будем включать ребра с цветами color(re1) и y.
Если один из найденных двухцветных циклов будет содержать также и ребро re2, то по этому циклу и нужно выполнить восстановление исходного ребра, которое было удалено из графа при редуцировании.
Отметим, что в общем случае нет гарантии, что один из найденных двухцветных циклов будет содержать ребро re2 (исследования в работе [14] касаются только плоских кубических графов, а дуальный граф поверхностной сетки не обязательно будет плоским), в этом случае корректировка реберной раскраски невозможна, и исходных граф не допускает раскраску Тейта.
Однако в ходе экспериментов по раскраске кубических дуальных графов, построенных по замкнутым поверхностным расчетным сеткам, такая ситуация не наблюдалась и для всех таких графов раскраска Тейта была найдена.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/8-restore-and-repaint.pdf}
\singlespacing
\captionstyle{center}\caption{Восстановление и раскраска графа.}
\label{fig:text_3_edge_coloring_8}
\end{figure}

На рис. 8 приведена последовательность восстановления графа, редуцирование которого продемонстрировано на рис. 3.
Приведем еще раз историю редуцирования графа.

e0 [(v0 : e3, e8 -> re12), (v1 : e1, e9 -> re13)]
e2 [(v2 : e13, e10 -> re14), (v3 : e12, e11 -> re15)]
e5 [(v5 : e4, e14 -> re16), (v6 : e6, e14 -> re16)]

Первый шаг восстановления относится к редуцированию по параллельному ребру. Ребро e16 разбивается на три ребра e6, e14, e4 с помощью вершин v6 и v5.
Между вершинами v6 и v5 восстанавливается ребро e5.
Ребра e6 и e4 наследуют зеленый цвет ребра e16, а ребра e14 и e5 раскрашиваются в два оставшиеся цвета.

Второй шаг восстановления относится к редуцированию по уникальному ребру.
Сначала ищется красно-синий цикл, содержащий ребро e14. Так как он не содержит ребро e15, то цикл из двух ребер e14-e5 перекрашивается.
После этого ищется сине-зеленый цикл, содержащий ребро e14.
Это цикл e14-e6-e15-e4, и он содержит ребро e15.
Происходит восстановление ребра по найденному двухцветному циклу.

Третий шаг восстановления также относится к редуцированию по уникальному ребру.
Так как существует сине-красный цикл e12-e2-e13-e5-e6-e7, то сразу можно выполнить восстановление ребра по этому циклу (а в данном случае можно выполнить восстановление и по сине-зеленому циклу, что приведет к другой раскраске).

Очевидно, что описанный алгоритм имеет квадратичную сложность по порядку графа, так как количество шагов восстановления пропорционально порядку исходного графа, а на каждом шаге восстановления уникального ребра необходимо выполнять поиск и перекраску двухцветных циклов, что в худшем случае пропорционально порядку текущего графа.

\subsubsection{Анализ полученных результатов}

Если мы рассматриваем кубический граф порядка n, то он содержит 3n/2 ребер, причем n четно.
Если данный граф допускает правильную реберную раскраску в 3 цвета, то в каждый из цветов раскрашено ровно n/2 ребер.
Таким образом, множество ребер распадается на 3 одинаковых по размеру подмножеств ребер без конфликтов.
Вызывает интерес вопрос о процентном соотношении ребер, раскрашенных в разные цвета, для жадной раскраски в 5 цветов при порядке графа, стремящемся в бесконечность.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/9-bubble.pdf}
\singlespacing
\captionstyle{center}\caption{Генерация кубического графа.}
\label{fig:text_3_edge_coloring_9}
\end{figure}

Для экспериментального получения такого распределения будем строить искусственные кубические графы следующим образом.
В качестве нулевого графа возьмем кубический граф K4, далее последовательно в текущем кубическом графе будем случайным образом выбирать вершину и заменять ее на треугольную конструкцию, как показано на рис. 9.
Вполне очевидно, что получающиеся таким образом графы будут кубические, и что они допускают правильную реберную раскраску в три цвета.
К полученным сгенерированным описанным способом кубическим графам порядка более 105 был применен жадный линейный алгоритм реберной раскраски в 5 цветов.
Получившееся распределение цветов представлено на рис. 10.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/10-chart.png}
\singlespacing
\captionstyle{center}\caption{Распределение процентной доли цветов для разных раскрасок.}
\label{fig:text_3_edge_coloring_10}
\end{figure}

Из рис. 10 видно, что распределение цветов жадной раскраски устроено примерно следующим образом. Большинство ребер кубического графа практически равномерно раскрасилось в 3 цвета, однако для окрашивания около 10\% ребер потребовалось использование четвертого цвета, а для окрашивания около 1,5\% ребер пришлось задействовать пятый цвет.

Для оценки целесообразности применения реберной раскраски для устранения конфликтов по данным при расчете потоков в задаче моделирования процесса обледенения поверхности были выполнены запуски модельной задачи на одном вычислительном узле на базе микропроцессора Intel Xeon Phi Knights Landing 7290.
Данный микропроцессор имеет 72 ядра, на каждом из которых может быть запущено до 4 потоков.
Таким образом, на этом микропроцессоре возможно распараллеливание запуска на 288 потоков [16].

Для сравнения эффективности методов устранения конфликтов при параллельном расчете потоков через границы ячеек замерялась эффективность распараллеливания данного кода.
Эффективность распараллеливания кода считалась следующим образом. В качестве ускорения, достигаемого при распараллеливании на i потоков, бралась величина s(i) = t(1)/t(i), где t(i) – эталонное время вычислений при использовании одного потока, t(i) – время вычислений при использовании i потоков.
Под эффективностью распараллеливания понималась величина, вычисляемая как e(i) = s(i)/i. Смысл данной величины заключается в следующем. Можно предположить, что при идеальном распараллеливании вычислений с увеличением количества потоков ровно в k раз время выполнения уменьшается ровно в k раз.
Таким образом, в случае идеального распараллеливания s(i) = i, а e(i) = 1. Эффективность распараллеливания вычислений является удобным показателем качества исполняемого параллельного кода и сравнения различных вычислительных систем между собой.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_3_edge_coloring/11-chart.png}
\singlespacing
\captionstyle{center}\caption{Эффективность распараллеливания пересчета потоков для разных способов устранения конфликтов по данным.}
\label{fig:text_3_edge_coloring_11}
\end{figure}

Из рис. 11 можно заметить, что при использовании распараллеливания на относительно небольшое количество потоков нет существенной разницы между описанными методами устранения конфликтов.
Однако при возрастании количества используемых потоков метод реберной раскраски становится гораздо эффективнее, чем использование директивы omp atomic с точки зрения эффективности распараллеливания.

В процессе работы над оптимизацией программного обеспечения компьютерного моделирования обледенения поверхности было выявлено узкое место для распараллеливания вычислений на общей памяти, связанное с возникновением конфликтов по данным.
Эти конфликты по данным приводят к необходимости использования режима атомарного исполнения отдельных команд внутри распараллеленного цикла.
Также эти конфликты создают существенные препятствия для векторизации кода.
Для устранения конфликтов был рассмотрен и предложен альтернативный подход, основанный на построении реберной раскраски дуального графа расчетной сетки. Для построения реберных раскрасок были рассмотрены два алгоритма.
Первый алгоритм – тривиальный жадный линейный алгоритм раскраски в 5 цветов.
Второй алгоритм – квадратичный алгоритм построения раскраски Тейта, основанный на последовательном редуцировании и восстановлении графа.
В ходе экспериментов было выявлено, что при использовании большого количества потоков при распараллеливании использование реберной раскраски является более эффективным методом устранения конфликтов.
Также следует отметить, что конкретный алгоритм раскраски графа не оказывает влияние на эффективность расчетов, то есть для практического применения может быть применим простой алгоритм раскраски в 5 цветов.
