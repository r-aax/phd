% Векторизация метода погруженных границ.
\subsection{Векторизация трехмерного метода погруженных границ}

\subsubsection{Постановка задачи газовой динамики и локализация пригодных для векторизации участков программного кода}

Будем рассматривать систему уравнений газовой динамики в трехмерном виде, которая выглядит следующим образом:
\begin{equation}
	\frac{\partial}{\partial t} U + \frac{\partial}{\partial x} F + \frac{\partial}{\partial y} G + \frac{\partial}{\partial z} H = 0 \\
\end{equation}

\begin{equation}
U = \begin{pmatrix}
	\rho \\
	\rho u \\
	\rho v \\
	\rho w \\
	E
\end{pmatrix}, \
F = \begin{pmatrix}
	\rho u \\
	\rho u^2 + p \\
	\rho u v \\
	\rho u w \\
	u (E + p)
\end{pmatrix}, \
G = \begin{pmatrix}
	\rho v \\
	\rho u v \\
	\rho v^2 + p \\
	\rho v w \\
	v (E + p)
\end{pmatrix}, \
H = \begin{pmatrix}
	\rho w \\
	\rho u w \\
	\rho v w \\
	\rho w^2 + p \\
	w (E + p)
\end{pmatrix}
\end{equation}

\begin{equation}
	E = \rho \left( \frac{V^2}{2} + e \right), \ V^2 + u^2 + v^2 + w^2, \ e(p, \rho) = \frac{p}{\rho (\gamma - 1)}
\end{equation}

Данную систему будем численно решать с помощью метода конечных объемов путем вычисления потоков вектора $F$ через грани ячейки, перпендикулярные направлению сетки $i$, вектора $G$ через грани ячейки, перпендикулярные направлению сетки $j$, вектора $H$ через грани ячейки, перпендикулярные направлению сетки $k$ (при вычислении используем декартову сетку с кубическими ячейками, то есть дискретизация пространства выполняется с одним и тем же шагом по всем трем направлениям):
\begin{equation}
	U_i^{n + 1} = U_i^n - \frac{\Delta t}{\Delta h}(F_{i + \frac{1}{2}} - F_{i - \frac{1}{2}} + G_{j + \frac{1}{2}} - G_{j - \frac{1}{2}} + H_{k + \frac{1}{2}} - H_{k - \frac{1}{2}})
\end{equation}

Для вычисления потоков будем использовать противопоточную схему Steger-Warming [9], в которой потоки получаются следующим образом (на примере потока $F$):
\begin{equation}
	F_{i + \frac{1}{2}} = F_i^{+}(U_i^n) + F_i^{-}(U_{i + 1}^n)
\end{equation}

\begin{equation}
	F^{\pm} = \frac{\rho}{2 \gamma}
	\begin{pmatrix}
		\lambda_1^{\pm} + 2(\gamma - 1)\lambda_2^{\pm} + \lambda_5^{\pm} \\
		(u - a)\lambda_1^{\pm} + 2(\gamma - 1)u\lambda_2^{\pm} + (u + a)\lambda_5^{\pm} \\
		v(\lambda_1^{\pm} + 2(\gamma - 1)\lambda_2^{\pm} + \lambda_5^{\pm}) \\
		w(\lambda_1^{\pm} + 2(\gamma - 1)\lambda_2^{\pm} + \lambda_5^{\pm}) \\
		(H - ua)\lambda_1^{\pm} + (\gamma - 1)V^2\lambda_2^{\pm} + (H + ua)\lambda_5^{\pm}
	\end{pmatrix}
\end{equation}

\begin{equation}
	\lambda_i^{\pm} = \frac{\lambda_i \pm |\lambda_i|}{2}, \ \lambda_1 = u - a, \ \lambda_2 = \lambda_2 = \lambda_4 = u, \ \lambda_5 = u + a, \ H = \frac{E + p}{\rho}
\end{equation}

С учетом приведенных формул один шаг выполнения расчетов с использованием метода погруженных границ должен содержать следующие необходимые действия:

1)	Для всех GHOST ячеек сетки выполнение аппроксимации примитивных газодинамических величин $D = [\rho, u, v, w, p]$ на основе единожды вычисленных шаблонов (подготовку шаблонов и предварительное вычисление матриц не рассматриваем, так как это однократное действие, вклад которого в общем процессе расчета стремится к нулю при увеличении времени расчетов).
Данное действие обозначим \texttt{approximate\_values}.
2)	Для всех GHOST и COMMON ячеек сетки получение из вектора примитивных газодинамических величин $D = [\rho, u, v, w, p]$ вектора консервативных величин $U = [\rho, \rho u, \rho v, \rho w, E]$.
Данное действие будем обозначать \texttt{d\_to\_u}.
3)	Для всех GHOST и COMMON ячеек сетки вычисление векторов потоков $F^{\pm}$, $G^{\pm}$ и $H^{\pm}$.
Эти действия обозначим как \texttt{calc\_fgh}.
4)	Для всех COMMON ячеек корректировка вектора консервативных величин $U = [\rho, \rho u, \rho v, \rho w, E]$ с помощью потоков.
Обозначим это действие \texttt{calc\_flows}.
5)	Для всех COMMON ячеек обратных пересчет вектора консервативных величин $U = [\rho, \rho u, \rho v, \rho w, E]$ в вектор примитивных величин $D = [\rho, u, v, w, p]$.
Данное действие обозначим \texttt{u\_to\_d}.

Схема выполнения расчетов продемонстрирована на рис. 4.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{./pics/text_4_ibm/immersed_boundary_method_scheme.pdf}
	\caption{Схема выполнения шага расчетов методом погруженных границ с использованием схемы Steger-Warming.}
	\label{fig:text_4_ibm_immersed_boundary_method_cheme}
\end{figure}

Использование метода погруженных границ с фиктивными ячейками позволяет проводить газодинамические расчеты вблизи сложных границ без необходимости построения согласованных сеток.
С помощью описанного метода и с применением схемы расчета Steger-Warming были проведены расчеты модельной задачи обтекания свободным потоком множества случайных сфер (при этом граница обтекаемых объектов для простоты задавалась аналитически, а не с помощью поверхностной сетки).
Реализация модельной задачи находится в публичном репозитории.
Для расчетов использовалась простая декартова расчетная сетка с кубическими ячейками.
Во время расчетов геометрическая конфигурация оставалась неизменной, что сделало возможным однократное вычисление вспомогательных объектов для аппроксимации газодинамических величин в фиктивных ячейках (в том числе речь идет о матрицах $B_{G123}^{-1}$ и $B_{0'123}^{-1}$).
С помощью метода погруженных границ на декартовой расчетной сетке можно получить качественно правильную картину обтекания, что проиллюстрировано на рис. 5.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{./pics/text_4_ibm/res.pdf}
	\caption{Визуализация поля скоростей (двумерный срез), полученного с помощью метода погруженной границы на расчетной сетке с рис. 2.}
	\label{fig:text_4_ibm_res}
\end{figure}

Проведение вычислений на достаточно подробных расчетных сетках с высоким уровнем дискретизации по пространству и времени требует серьезных вычислительных ресурсов.
Для обработки крупных расчетных областей целесообразно применение высокопроизводительных вычислительных кластеров с использованием различных средств повышения быстродействия приложений и распараллеливания вычислений.
Основными уровнями распараллеливания являются организация вычислений на распределенной памяти (например, с использованием MPI [10]), использование многопоточного программирования (например, с использованием средств OpenMP [11]), а также векторизация программного кода [12], что является низкоуровневой оптимизацией, способной кратно увеличить эффективность исполняемого кода.

В рамках данной работы проводился эксперимент по организации программного кода газодинамического решателя, работающего в данными в формате double (вещественные числа размера 64 бита) с целью векторизации под микропроцессоры Intel Xeon Phi Knights Landing [15].
Данный микропроцессор был выбран, так как кроме обычных векторных арифметических операций набора AVX-512F он поддерживает также такие полезные наборы, как AVX-512PF -- операции предварительной подкачки данных из памяти и AVX-512ER -- векторные команды для вычисления экспоненты и обратных значений, которые крайне полезны в физических приложениях.

Рассмотрим на примере реализации функции \texttt{d\_to\_u} из общей схемы вычислений, представленной на рис. 4, способы организации вычислений интуитивным способом и в виде плоского цикла.
Итак, функция \texttt{d\_to\_u} переводит вектор примитивных газодинамических величин $D$ в вектор консервативных величин $U$ для каждой расчетной ячейки.
Интуитивным способом вычисления могут быть организованы в виде следующей схемы: для каждой ячейки создается структура, которая содержит все необходимые величины, и действия по переводу вектора $D$ в вектор $U$ выполняется над полями данной структуры (листинг 1, слева).
При попытке векторизации данного цикла во время объединения нескольких последовательных итераций (объединяться должны 8 итераций, так как размер элемента данных равен 64 бита, а длина векторного регистра равна 512 бит) вместо чтения из памяти скалярного значения (например, плотности), должно происходить чтение значений плотности из несколько последовательно расположенных структур данных.
То есть чтение вектора должно осуществляться не из последовательной области памяти.
Для таких целей в наборе векторных инструкций AVX-512 предусмотрены инструкции gather/scatter, однако их эффективность гораздо ниже чтения последовательной области памяти размера 512 бит даже при использовании предварительной подкачки данных.

\begin{lstlisting}[caption={caption},label={label}]
struct Cell
{
    double rho;
    double u;
    double v;
    double w;        // 
    double p;        // 
    double rho_u;    // 
    double rho_v;
    double rho_w;
    double E;
};

Cell cells[N];

void d_to_u()
{
    for (int i = 0; i < N; i++)
    {
        double rho = cells[i].rho;
        double u = cells[i].u;
        double v = cells[i].v;
        double w = cells[i].w;
        double p = cells[i].p;

        cells[i].rho_u = rho * u;
        cells[i].rho_v = rho * v;
        cells[i].rho_w = rho * w;
        cells[i].E = 0.5 * rho
                     * (u * u + v * v + w * w)
                     + p / (GAMMA - 1.0);
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={caption},label={label}]
double rhos[N];
double us[N];
double vs[N];
double ws[N];        // 
double ps[N];        // 
double rho_us[N];    // 
double rho_vs[N];
double rho_ws[N];
double Es[N];

void d_to_u()
{
    for (int i = 0; i < N; i++)
    {
        double rho = rhos[i];
        double u = us[i];
        double v = vs[i];
        double w = ws[i];
        double p = ps[i];

        rho_us[i] = rho * u;
        rho_vs[i] = rho * v;
        rho_ws[i] = rho * w;
        Es[i] = 0.5 * rho
                * (u * u + v * v + w * w)
                + p / (GAMMA - 1.0);
     }
}
\end{lstlisting}

Естественным решением оптимизации вычислений является организация расположения данных в памяти в виде набора массивов (листинг 1, справа).
Теперь после объединения нескольких итераций цикла команды скалярного доступа в память трансформируются в векторные аналоги доступа к последовательной области памяти размера 512 бит.
Вся же арифметика, которая присутствует в коде функции (операции сложения, вычитания, умножения, деления, взятие обратной величины) имеет свои векторные аналоги в наборе инструкций AVX-512.

Другой критической проблемой, влияющей на эффективность векторизации кода, является наличие условных операций внутри векторизуемого плоского цикла.
Конечно набор инструкций AVX-512 содержит специальные масочные аргументы, с помощью которых можно векторизовать программный код с управлением практически любой сложности (разветвленное управление, гнезда циклов, циклы с вызовами функций, циклы с нерегулярным числом итераций) [16], однако при увеличении количества условий в коде эффективность векторизации снижается.

В качестве примера такого негативного эффекта можно рассмотреть логику гнезда циклов из функции \texttt{calc\_flows}, в которой корректируются консервативные величины с помощью потоков через все грани ячейки.
Пусть рассматриваемая расчетная область представлена структурированной сеткой размера NX - NY - NZ по направлениям i, j, k соответственно.
Тогда при учете потоков через левую грань каждой ячейки необходимо отдельно обрабатывать случай i = 0, что соответствует граничному условию расчетной области, причем данное граничное условие может быть разных видов (свободное протекание, условие жесткой стенки) (см. листинг 2, слева).
Аналогично нужно рассматривать особые случаи для всех шести граней ячейки, что резко увеличивает количество условий внутри цикла и снижает эффективность векторизации.

\begin{lstlisting}[caption={caption},label={label}]
for (int k = 0; k < NZ; k++)
{
    for (int j = 0; j < NY; j++)
    {
        for (int i = 0; i < NX; i++)
        {
            if (i == 0)
            {
                // left boundary condition
                ...
            }

            // rest code
            ...
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={caption},label={label}]
for (int k = 0; k < NZ; k++)
{
    for (int j = 0; j < NY; j++)
    {
        // left boundary condition with i = 0
        ...
    }
}

for (int k = 0; k < NZ; k++)
{
    for (int j = 0; j < NY; j++)
    {
        for (int i = 1; i < NX; i++)
        {
            // rest code
            ...
        }
    }
}
\end{lstlisting}

Можно заметить, что условия обработки границ расчетной области не являются уникальными для тройки координат ячейки (i, j, k), но являются константными для некоторого среза ячеек сетки.
Это означает, что для гнезда циклов такое условие является частично константным, и гнездо может быть разбито по этому условию.
На листинге 2 справа продемонстрировано разбиение гнезда циклов по условию i = 0, после чего итоговое гнездо, содержащее основную часть вычислений, освобождается от условия.
Аналогичным образом можно выполнить разбиение по остальным условиям, освободив от них основное гнездо циклов, которое после этого успешно векторизуется.

На рис 4. представлена общая схема выполнения расчетов для одной итерации численного метода.
Основными функциями в этих расчетах являются \texttt{approximate\_values}, \texttt{d\_to\_u}, \texttt{calc\_fgh}, \texttt{calc\_flows}, \texttt{u\_to\_d}.
Во время проведения эксперимента на модельной задаче был собран профиль исполнения до векторизации и после нее, результаты распределения времени исполнения между этими основными функциями представлены на рис. 6.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{./pics/text_4_ibm/diagr.png}
	\caption{}
	\label{fig:text_4_ibm_diagr}
\end{figure}

Также на рис. 7 представлены результаты ускорения после векторизации каждой функции в отдельности и суммарного ускорения всего расчетного кода.
Заметим, что во время векторизации расчетного кода, работающего с вещественными числами двойной точности, один векторный регистр содержит 8 элементов данных.
Можно эмпирически считать, что при замене в плоском цикле всех скалярных инструкций на точные векторные аналоги логическое ускорение составит 8 раз (количество инструкций в итерации цикла останется неизменным, но количество итераций в плоском цикле уменьшится в 8 раз). Однако на практике ускорение в 4 раза уже можно считать успешным.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{./pics/text_4_ibm/diagr2.png}
	\caption{}
	\label{fig:text_4_ibm_diagr2}
\end{figure}

Заметим, что ускорение различных функций в результате векторизации сильно отличается друг от друга.
Причиной этому являются конкретные особенности каждой из этих функций.

Наибольшее ускорение продемонстрировала функция \texttt{calc\_fgh}, реализующая вычисление потоков $F^{\pm}$, $G^{\pm}$, $H^{\pm}$.
Этому способствовали следующие особенности данной функции.
Во-первых, функция содержит плоский цикл, полностью удовлетворяющий всем условиям, что делает возможным замену всех скалярных операций на векторные аналоги.
Во-вторых, в скалярной версии используются библиотечные вызовы abs (вычисление абсолютного значения) и sqrt (вычисление квадратного корня).
В наборе векторных инструкций AVX-512 есть векторные операции VAND (с помощью побитовой операцией над вещественным числом можно обратить в ноль бит знака данного числа), VSQRT, которые реализуют эти действия просто одной операцией, что сильно ускоряет исполнение.
Наконец, обилие операций умножения и сложения делает возможным применение векторных комбинированных операций вида $\pm a \cdot b \pm c$.

Также ускорение выше среднего продемонстрировали функции \texttt{d\_to\_u} и \texttt{u\_to\_d}.
Эти функции также состоят из плоских циклов, поэтому скалярные операции могут быть заменены на векторные аналоги.
Более низкое ускорение функции \texttt{u\_to\_d} объясняется наличием операций деления, которые выполняются медленнее операций сложения и умножения.

Показатель ускорения функции \texttt{calc\_flows} составил менее двух раз даже после избавления от всех условий, связанных с обработкой границ расчетной области.
Такая низкая эффективность векторизации объясняется тем, что внутри этой функции присутствуют циклы, которые не являются плоскими.
Так, например, в функции \texttt{calc\_flows} для корректировки консервативных величин внутри ячейки \texttt{(i, j, k)} требуется обращаться за данными ко всем смежным по граням ячейкам: (i +- 1, j, k), (i, j +- 1, k), (i, j, k +- 1).
Это нарушает требование по унификации обращения к массивам данных на одной итерации плоского цикла и немедленно приводит к появлению операций gather/scatter, понижая эффективность векторизации.
Для функции \texttt{approximate\_values} ситуация выглядит аналогичной, так как для выполнения аппроксимации данных в ячейке (i, j, k) требуется обращаться за данными в ячейки, относящиеся к шаблону аппроксимации (на рис 4. нарушение требования унификации обращения за данными продемонстрировано красными стрелками, означающими, что при обработке одной ячейки сетки мы вынуждены обращаться за данными к другой ячейке).

Несмотря на низкие показатели эффективности векторизации функций, содержащих циклы, не являющиеся плоскими, общая эффективность от векторизации метода погруженных границ составила примерно три раза, при этом удалось ограничиться только реорганизацией кода без использования ассемблера или функций-интринсиков для формированного использования векторных инструкций.
