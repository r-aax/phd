% Векторизация - целочисленный контекст.
\subsection{Векторизация целочисленного программного \\ контекста}

В разделах~\ref{sec:text_4_vec_riemann} и \ref{sec:text_4_vec_irreg} были рассмотрены подходы к векторизации\label{term:vectorization5} плоских циклов\label{term:flat_loop5} с телом в виде циклов с непостоянным количеством итераций.
В этих разделах входными данными рассматриваемой задачи являлись массивы вещественнных чисел.
В этом разделе будет рассмотрен пример векторизации для так называемого целочисленного программного контекста\label{term:integer_context}.
Под целочисленным программным контекстом будем подразумевать программный код, в котором преобладают целочисленные вычисления, а также ведется работа с дискретными структурами данных.
Работа целочисленным программным контекстом отличается, как правило, наличием циклов с нерегулярным количеством итераций, а также нерегулярными обращениями в память в косвенностью и частыми промахами в кеш.
В качестве примера целочисленного программного контекста будем рассматривать алгоритм декомпозиции графа из раздела~\ref{sec:text_2_genetic}.

Рассмотренный в разделе~\ref{sec:text_2_genetic} алгоритм пузырькового роста\label{term:alg_decomp_bubble2}, используемый в генетическом алгоритме декомпозиции\label{term:alg_decomp_gen2} графа, требует для своего применения эффективной реализации, так как в составе генетического алгоритма он должен исполняться многократно для одного и того же графа, но с разными настройками декомпозиции, закодированными в генотипе декомпозиции\label{term:genotype3}.
Этот алгоритм работает с целочисленным программным контекстом и может быть векторизован с помощью векторных операций над упакованными целыми числами.

\subsubsection{Скалярная реализация алгоритма пузырькового роста}

Рассмотрим возможности по ускорению алгоритма пузырьковго роста с помощью векторизации.
Пусть на вход в алгоритм, реализованный на языке C++, подается граф, информация о его ребрах записана в массиве \texttt{inc}, где \texttt{inc[i]} –- массив номеров всех вершин, смежных с вершиной $i$.
Номера доменов\label{term:domain6}, к которым относятся конкретные вершины хранятся в массиве \texttt{domains}.
В алгоритме пузырькового роста домены наращиваются последовательно с помощью алгоритма обхода графа в ширину, начиная от инициирующих вершин.
Структура \texttt{q} -- массив очередей вершин, ожидающих попадания в домены, в начале работы алгоритма очередь \texttt{q[i]} содержит только одну инициирующую вершину $i$-го домена.
В качестве масссива и очереди используются структуры STL\label{abbr:stl} vector и queue соответственно.
Пусть требуется выполнить декомпозицию (или раскраску вершин графа) на \texttt{domains\_count} доменов.
Тогда простейшая реализация алгоритма пузырькового роста доменов от инициирующих вершин может иметь следующий вид (см. листинг~\ref{lst:text_4_vec_integer}):

\begin{lstlisting}[caption={Реализация алгоритма пузырькового роста доменов.},label={lst:text_4_vec_integer}]
while (is_q)
{
    is_q = false;

    for (size_t c = 0; c < domains_count; ++c)
    {
        if (q[c].empty()) continue;

        is_q = true;
        n = q[c].front();
        q[c].pop();

        if (domains[n] == -1)
        {
            domains[n] = c;
            for (auto ngh : inc[n]) q[c].push(ngh);
        }
    }
}
\end{lstlisting}

Реализация алгоритма представляет собой гнездо из 3 циклов.
Внешний цикл выполняется до тех пор, пока найдется хотя бы одна непустая очередь домена.
Средний цикл выполнятся по номерам доменов.
Для каждого домена берется первая необработанная вершина из соответствующей очереди, и если она еще не отнесена ни к одному домену, то она заносится в текущий домен, а все ее соседи отправляются в очередь.
Внутренний цикл -- цикл по всем соседям только что обработанной вершины, которые должны быть занесены в очередь.
Будем выполнять векторизацию представленного кода по среднему циклу, и для простоты анализа приведем реализацию для фиксированного значения \texttt{domains\_count = 16} (это позволит избавиться от среднего цикла, и заменить его набором отдельных векторных операций).

Для выполнения векторизации вначале необходимо избавиться от STL структур vector и queue, так как они имеют свою внутреннюю реализацию, и векторизация операций по работе с ними невозможна.
Вместо структуры \texttt{vector<int>} будем хранить информацию о списке соседних вершин просто в массиве, 0-м элементом которого будет его размер.
Очередь queue также будет имитировать с помощью массива и индексов \texttt{front} и \texttt{back}, указывающих на первый и последний элементы очереди соответственно.
Тогда операция \texttt{push(v)} будет соответствовать записи в массив по индексу \texttt{back} с его продвижением, а операция \texttt{pop} будет соответствовать просто продвижению индекса \texttt{front}.
Очередь пуста если ее индекс \texttt{front} больше индекса \texttt{back}.

\subsubsection{Векторная реализация алгоритма пузырькового роста}

\begin{figure}[ht]
\centering
\includegraphics[width=0.90\textwidth]{pics/text_4_vec_integer/code.pdf}
\singlespacing
\captionstyle{center}\caption{Векторизация программного кода алгоритма пузырькового роста путем замены скалярных инструкций векторными аналогами.}
\label{fig:text_4_vec_integer_code}
\end{figure}

На рис.~\ref{fig:text_4_vec_integer_code} представлены скалярная и векторная версии программного кода реализации алгоритма пузырькового роста.
Полная версия исходного кода доступна в \cite{comboptGithub}.
В векторной версии \texttt{ADD} обозначает функцию-интринсик\label{term:intrinsic7} \texttt{\_mm512\_mask\_add\_epi32}, \texttt{GTH} и \texttt{SCT} -- аналогично представляют собой краткие имена для интринсиков операций gather и scatter.
Обозначения \texttt{GTH2} и \texttt{SCT2} -- это те же операции \texttt{GTH} и \texttt{SCT}, только использующие сразу два смещения от базового адреса).
Через \texttt{CMPLE}, \texttt{CMPLT} обозначены вызовы функции-интринсика \texttt{\_mm512\_mask\_cmp\_epi32\_mask} с параметрами сравнения \texttt{\_MM\_CMPINT\_LE} и \texttt{\_MM\_CMPINT\_LT} соответственно.
На рис.~\ref{fig:text_4_vec_integer_code} цифрой <<1>> обозначена векторизация условия продолжения выполнения внешнего цикла (цикл завершает работу, если все очереди доменов пусты).
Цифрой <<2>> обозначена векторизация извлечения следующей вершины из каждой очереди.
Цифрой <<3>> обозначена проверка принадлежности извлеченных вершин к какому-либо домену (в векторной версии формируется маска \texttt{is\_no\_domain} -- маска с номерами доменов, в которые добавляется новая вершина).
Цифрой <<4>> обозначена векторизация помещения рассматриваемой вершины в текущий домен и получение количества ее соседей. 
Цифра <<5>> -- обработка всех соседей только что помещенной в домен вершины, и цифра <<6>> -- добавление этих соседей в соответствующие очереди.

Стоит отметить, что векторизованная версия представленного алгоритма не является полностью эквивалентной скалярной версии. 
Вполне может оказаться, что на какой-то итерации внешнего цикла из двух или более разных очередей одновременно будет извлечена одна и та же вершина.
В этом случае в векторной версии она будет отнесена к домену с наибольшим номером (хотя в скалярном аналоге, она бы попала в домен с меньшим номером).
Это несоответствие можно устранить путем разворачивания векторов \texttt{vn} и \texttt{vc} при записи в массив \texttt{domains} (цифра «4» на рис.~\ref{fig:text_4_vec_integer_code}), но это не делалось, чтобы не усложнять код.

\subsubsection{Оценка эффективности векторизации алгоритма пузырькового роста}

Для оценки эффективности проведенной векторизации были произведены запуски на дуальных графах\label{term:dual_graph4} поверхностных прямоугольных расчетных сеток со стороной от 20 до 2000 ячеек (то есть на графах с количеством вершин от 400 до 4 млн).
На рис.~\ref{fig:text_4_vec_integer_stat} представлена собранная статистика плотности масок\label{term:vector_mask_density6} (доля выставленных битов) векторных операций различных типов.
Из графиков на рис.~\ref{fig:text_4_vec_integer_stat} можно сразу сделать вывод о невысокой эффективности векторизации, так как плотность масок арифметических операций и операций записи в память оказались довольно низкими (примерно 0,3 и 0,25 соответственно).

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{pics/text_4_vec_integer/chart_statistics_rus.png}
\singlespacing
\captionstyle{center}\caption{Средняя плотность масок разных классов операций AVX-512\label{abbr:avx8} в зависимости от размера стороны расчетной сетки.}
\label{fig:text_4_vec_integer_stat}
\end{figure}

Замеры реального ускорения выполнялись для тех же графов на микропроцессоре Intel Xeon Phi 7290 KNL\label{abbr:knl15}, результаты представлены на рис.~\ref{fig:text_4_vec_integer_sp}, для удобства приведен также график сглаженного показателя ускорения.

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{pics/text_4_vec_integer/chart_speedup_rus.png}
\singlespacing
\captionstyle{center}\caption{Ускорение и эффективность векторизации\label{term:vec_eff7} алгоритма пузырькового роста в зависимости от размера стороны расчетной сетки.}
\label{fig:text_4_vec_integer_sp}
\end{figure}

Замеры ускорения продемонстрировали ускорение в диапазоне 1,7-2,2 раза для рассматриваемых графов с количеством ячеек от 400 до 4 млн.
Анализируя график сглаженного показателя ускорения, можно отметить, что максимум наблюдается при размере стороны расчетной сетки в районе 750 и равен примерно 1,95.
Снижение ускорения при уменьшении стороны расчетной сетки связано с увеличение количества конфликтов при обработке следующих вершин из очередей доменов.
Снижение ускорения при увеличении стороны расчетной сетки связано с увеличением разброса смещений при выполнении операций gather/scatter, что приводит к промахам в кэш-память.

Можно отметить, что продемонстрированные невысокие результаты ускорения объясняются прежде всего нерегулярным количеством итераций циклов в гнезде, а также обилием операций множественного обращения в память gather/scatter.
Значение ускорения в районе 1,95 хорошо согласуется с данными, полученными на вещественном программном контексте с гнездами циклов с нерегулярным количеством итераций, которые были описаны в разделе~\ref{sec:text_4_vec_irreg} на примере сортировки Шелла\label{term:shell_sort2}.
