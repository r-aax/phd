% Векторизация операций над матрицами малой размерности.
\subsection{Векторизация операций над матрицами малой размерности для процессора \\ Intel Xeon Phi Knights Landing}

\subsubsection{Умножение матрицы $8 \times 8$ на вектор}

Реализация неоптимизированной версии может выглядеть следующим образом:

\begin{lstlisting}[caption={Невекторизованная версия умножения матрицы размера $8 \times 8$ на вектор},label={lst:text_4_small_matr_8x8_mul_vel_noopt}]
void matvec8_orig(float* __restrict m,
                  float* __restrict v,
                  float* __restrict r)
{
    for (int i = 0; i < V8; i++)
    {
        float sum = 0.0;
        int ii = i * V8;

        for (int j = 0; j < V8; j++)
        {
            sum = sum + m[ii + j] * v[j];
        }

        r[i] = sum;
     }
}
\end{lstlisting}

Рассмотрим некоторые моменты реализации.
Матрица хранится в сплошной области памяти по строкам и передается в фунцию через указатель на начало этой области.
Все параметры функции передаются c указанием \texttt{\_\_restrict} для облегчения компилятору задачи по оптимизации.
Умножение матрицы на вектор состоит в вычислении скалярного произведения каждой строки этой матрицы на вектор и составлении из результатов выходного вектора.
Так как в данном случае размер строки матрицы равен 8 элементам типа float, то одной операцией в 512-битный регистр можно загрузить из памяти сразу 2 соседние строки матрицы.
После чего нужно выполнить операцию упакованного умножения на регистр, содержащий две копии вектора, на который умножается матрица (выполнить запись двух копий вектора в zmm регистр можно с помощью операции gather).
Сумма первых восьми элементов получившегося регистра и последних восьми элементов будут являться элементами выходного вектора r (см. рис. 1).

Итак, при реализации операции умножения матрицы 8x8 на вектор мы должны загрузить всю матрицу в четыре zmm регистра.
Затем выполнить четыре упакованные операции умножения этих регистров, на регистр, содержащий две копии вектора, на которые умножается матрица.
После этого из каждого из получившихся четырех регистров мы должны получить сумму элементов каждой его половины, что в результате даст 8 искомых элементов выходного вектора.
Получение суммы элементов половины zmm регистра представляет собой как раз ту горизонтальную операцию, реализация которой в помощью интринсика оказывается слишком дорогой.
Как показали эксперименты, простое применение интринсика \texttt{\_mm512\_mask\_reduce\_add\_ps} (и даже безмасочного \texttt{\_mm512\_reduce\_add\_ps} в случае умножения матрицы 16x16) не приводит к ускорению по сравнению с оригинальной версией функции, оптимизированной компилятором icc с использованием уровня оптимизации -O3.
Прежде чем переходить к оптимизации данных горизонтальных операций рассмотрим второй интересующий нас пример, -- перемножение двух матриц размера 8x8, -- и убедимся, что в этом случае проявляется та же проблема.
Как и в случае с первым примером, вначале приведем простую реализацию неоптимизированной версии перемножения двух матриц размера 8x8:

\begin{lstlisting}[caption={Невекторизованная версия перемножения матриц размера $8 \times 8$}, label={lst:text_4_small_matr_8x8_mul_matr_noopt}]
void matmat8_orig(float* __restrict a,
                  float* __restrict b,
                  float* __restrict r)
{
    for (int i = 0; i < V8; i++)
    {
        int ii = i * V8;
 
        for (int j = 0; j < V8; j++)
        {
            float sum = 0.0;

            for (int k = 0; k < V8; k++)
            {
                int kk = k * V8;
                
                sum = sum + a[ii + k] * b[kk + j];
            }

            r[ii + j] = sum;
        }
    }
}
\end{lstlisting}
