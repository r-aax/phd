% Описательная часть про векторизацию.

Векторизация вычислений это низкоуровневая оптимизация, правильное применение которой способно кратно повысить производительность наиболее горячих участков программного кода и сократить энергопотребление \cite{Cebrian2019VecScal}.
Использование векторных инструкций позволяет применять одинаковые операции сразу к нескольким наборам входных данных, упакованных в векторные регистры.
На сегодняшний день наиболее продвинутым набором векторных инструкций является AVX-512, поддержку которого можно встретить в микропроцессорах Intel и AMD.
Инструкции AVX-512 работают с векторными регистрами (zmm) размера 512 бит, каждый из которых вмещает в себя 8 элементов в формате вещественных чисел двойной точности, что с учетом комбинированных операций приводит к возможности выполнения 16 операций сложения и умножения двойной точности за одну векторную команду.
Из этого следует, что на микропроцессорах с поддержкой AVX-512 без использования векторизации даже теоретически невозможно добиться производительности более 6,25\% от пиковой производительности.
Особенности векторных инструкций AVX-512 позволяют применять их для векторизации достаточно сложного программного контекста, однако оптимизирующий компилятор не всегда успешно справляется с этой задачей.
Для обеспечения программисту возможности прямого использования векторных инструкций существует набор функций-интринсиков, которые в дальнейшем заменяются компилятором на конкретные векторные инструкции или последовательности инструкций.
Использование интринсиков значительно упрощает разработку векторизованного кода и позволяет вести разработку кода в терминах функций, применяемых к векторным данным.

Можно считать, что впервые набор векторных инструкций AVX-512 был поддержан в 2016 году в микропроцессорах Intel Xeon Phi Knights Landing (так как более раннее поколение Intel Xeon Phi Knights Corner представляет собой ускоритель, и векторный код для него не является x86 совместимым).
С этого момента вопросы векторизации приложений активно обсуждаются в научных статьях.
Отметим наиболее заметные актуальные работы, в которых описаны существенные результаты по ускорению программных кодов, полученные с помощью векторизации.

В работе \cite{Kulikov2019VecAstro} путем векторизации безусловных операций было продемонстрировано повышение производительности газодинамического решателя на 200\% при исполнении на микропроцессорах Intel Xeon Phi KNL и Intel Xeon Scalable.
В работе \cite{Glinting2019VecSwim} описывается сравнение реализации римановских решателей в применении к теории мелкой воды, одним из результатов работы является ускорение решателя с помощью инструкций AVX-512 в 16,7 раз при работе с вещественными числами одинарной точности.
В исследовании \cite{Yildirim2021VecCFD} было достигнуто ускорение в 3,27 газодинамического решателя ADflow, работающего на структурированных расчетных сетках.
Ускорение достигнуто путем декомпозиции сетки на вычислительные блоки, которые могут быть эффективно обработаны с точки зрения использования кэш-памяти и применения векторных инструкций AVX-512.
В работе \cite{Rucci2020VecNBody} рассмотрена реализация расчета гравитационного взаимодействия между N телами, из результатов видно, что использование набора инструкций AVX-512 позволило ускорить работу приложения в 2 и более раз.
В работе \cite{Rucci2019VecSW} описано успешное применение векторных инструкций в задаче поиска сходных участков в белковых последовательностях.
Работы \cite{Choi2023VecKorean,Cheng2021VecCSIDH} посвящены ускорению алгоритмов, связанных с шифрованием.

В качестве практического руководства по созданию векторизованного программного кода с помощью функций-интринсиков для языка программирования C++ и с помощью языка ассемблера для широкого спектра практических задач, включая задачи линейной алгебры, обработки изображений, реализацию сверток и другие, можно рассматривать работу \cite{Kusswurm2022VecCpp}.

Среди научно-исследовательских статей в различных областях применения можно отметить \cite{Blacher2022VecQuick}, посвященную разработке векторизованной версии быстрой сортировки (vqsort) с помощью наборов векторных инструкций AVX2 и AVX-512, превышающей по эффективности реализацию из стандартной библиотеки (qsort) более чем в 10 раз.
В работе \cite{Long2022VecSPD} рассматриваются реализация бессеточного метода решения задачи газовой динамики и векторизация данного метода. 
Использование векторных инструкций AVX-512 позволило ускорить исходный код в 6,3 раза.
В статье \cite{PonteFernandez2022VecInteractions} описано успешное применение векторизации для алгоритма анализа генетических вариаций.
Использование векторных инструкций AVX-512 позволило добиться ускорения расчетов от 7 до 12 раз по сравнению с оригинальным алгоритмом (алгоритм базируется на обработке данных формата Byte, что объясняет такое серьезное ускорение).
В работе \cite{Quisland2023VecSeries} рассматривается прямое применение инструкций AVX-512 для задачи обработки временных рядов, что привело к ускорению результирующего кода в 4 раза по сравнению с автоматической векторизацией, выполняемой оптимизирующим компилятором. 
Статья \cite{Buhrow2022VecMult} посвящена оптимизации алгоритмов шифрования с открытым ключом, в частности, рассматривается оптимизация блочного варианта умножения Монтгомери.
Было достигнуто ускорение основных операций от 1,5 до 1,9 раза.
В статье \cite{Choi2022VecPIPO} показана реализация алгоритма блочного шифрования на различных архитектурах, включая GPU и CPU.
В частности, в рамках данной работы алгоритм блочного шифрования был реализован с помощью инструкций AVX-512, что позволило ускорить его в 9,5 раза по сравнению с оригиналом.
В статье \cite{Cheng2022VecSIKE} рассматривается применение векторных инструкций для оптимизации математических операций, используемых в протоколе обмена ключами с применением суперсингулярных изогений (SIKE). В результате выполненных усовершенствований зафиксировано ускорение отдельных операций в диапазоне от 1,5 до 3,5 раза.
В работе \cite{Sansone2023VecFourier} описано использование инструкций AVX-512 для оптимизации быстрого преобразования Фурье.
С помощью функций-интринсиков для векторных инструкций было достигнуто ускорение примерно в полтора раза по сравнению с оригинальной версией.
Работа \cite{Edamatsu2023VecDiv} посвящена применению подмножества инструкций Integer Fused Multiply-Add (AVX-512 IFMA) для повышения эффективности реализации деления больших целых чисел.
В результате оптимизации было достигнуто ускорение требуемого функционала на 25–35\%.
В работе \cite{Medakin2021VecPP} продемонстрирован практический подход к векторизации расчета попарного взаимодействия множества частиц.
Использование инструкций AVX-512 в явном виде привело к ускорению исполнения программы в 3,3 раза.

В статье \cite{Tayeb2023VecAuto} предлагается подход к развитию средств автоматической векторизации расчетных циклов, основанный на анализе и эквивалентных преобразованиях графа зависимостей между операциями, расположенными в теле цикла.
Этот подход позволяет переупорядочить операции внутри цикла, снизив их количество и укоротив критический путь исполнения \cite{Laukemann2019VecAuto}, и сгруппировать для объединения в векторные инструкции.

% Таблица векторных инструкций AVX-512.
\subsection{Векторные инструкции из набора AVX-512}

Набор инструкций AVX-512 -- это 512-битное расширение 256-битных AVX-инструкций из набора команд Intel x86, поддержанное в семействах микропроцессоров, начиная с Intel Xeon Skylake и Intel Xeon Phi Knights Landing.
Поддержка данного набора инструкций внедряется и для микропроцессоров AMD.

Множество инструкций AVX-512 состоит из нескольких подмножеств, их перечень расширяется с появлением новых поколений микропроцессоров (при этом в различных поколениях микропроцессоров поддержаны разные наборы подмножеств инструкций AVX-512) \cite{IntelSDM2025}.
Приведем краткое описание этих поднаборов.

AVX-512 F (Foundation) -- основной набор, который содержит в себе базовые операции для работы с векторными данными, включая арифметику, операции конвертации, сравнения, операции перестановки элементов векторов и другие.
Набор AVX-512 VL (Vector Length) позволяет расширить многие векторные инструкции для работы со 128-битными XMM регистрами и 256-битными YMM регистрами.
Набор AVX-512 BW (Byte and Word) расширяет инструкции для работы с элементами векторов размера 8 и 16 бит, а AVX-512 DQ (Doubleword and Quadword) добавляет новые инструкции, работающие с элементами размера 32 и 64 бита.

Набор AVX-512 CD (Conflict Detection) содержит операцию для нахождения пар совпадающих целых значений в двух векторах (VPCONFLICTD/Q), а также операции записи маски в элементы вектора и подсчета количества ведущих нулей в элементах вектора.
Операции подсчета количества единиц в элементах векторов определены в наборах AVX-512 BITALG (Bit Algorithms) и AVX-512 VPOPCNTDQ (Vector population count).

AVX-512 ER (Exponential and Reciprocal) включает в себя инструкции для вычисления значений $2^x$, $1/x$, $1/{x^2}$.

AVX-512 PF (PreFetch) содержит операции предварительной подкачки данных для VGATHERDPS/VSCATTERDPD, что позволяет уменьшить вероятность промаха в кэш.

Наборы AVX-512 VBMI (Vector Byte Manipulation Instructions) и AVX-512 VBMI2 добавляют новые операции, работающие с 8-битными данными, такие как перестановка элементов, чтение из памяти и запись в память, конкатенация со сдвигом.

AVX-512 IFMA (Integer Fused Multiply Add) содержат комбинированные операции над целыми числами, которые используются для реализации работы с большими числами или для шифрования \cite{Edamatsu2023VecDiv}.

Набор AVX-512 FP16 включает в себя арифметические операции и операции конвертации для работы с вещественными числами половинной точности, а набор AVX-512 BF16 добавляет инструкции для работы с форматом brain float 16 \cite{Kalamkar2019VecBF16}.

AVX-512 VNNI (Vector Neural Network Instructions) и AVX-512 4VNNIW содержат операции поэлементного перемножения пар целых чисел с последующим их сложением.
Операции выполняются над 8-битными и 16-битными данными и используются в задачах линейной алгебры, в частности для реализации искусственных нейронных сетей \cite{Zhou2024VecVNNI}.
Набор AVX-512 4FMAPS (Fused Multiply Accumulation Packed Single) содержит инструкции V4FMADDPS и V4FNMADDPS, реализующие комбинированные операции над четырьмя 512-битными операндами и значениями из памати, объединяя в себе 64 операции перемножения и 64 операции сложения вещественных чисел одинарной точности.

AVX-512 VPCLMULQDQ содержит операцию VPCLMULQDQ, предназначенную для перемножения 128-битных целых чисел.

AVX-512 VP2INTERSECT (Vector pair intersection) содержит операции VP2INTERSECTD и VP2INTERSECTQ, используемые для определения пересечений двух векторов 32-битных или 64-битных целых чисел \cite{DiezCanas2021VecVP2Int}.

AVX-512 VAES (Vector Advanced Encryption Standard) содержит векторные операции для поддержки симметричного алгоритма блочного шифрования \cite{Kovats2024VecAES}.

AVX-512 GFNI (Galois Field New Instructions) включает в себя операции для работы в конечном поле Галуа $GF(2^8)$, использование которых распространено для реализации алгоритмов шифрования \cite{Yoo2023VecGFNI}.

Для поддержки выборочного применения операций над упакованными данными к конкретным элементам векторов большинство инструкций AVX-512 использует специальные регистры-маски в качестве аргументов.
Всего таких регистров 8 (k0-k7).
Маски используются в командах для осуществления условной операции над элементами упакованных данных (если соответствующий бит выставлен в 1, то операция выполняется, а точнее результат операции записывается в соответствующий элемент вектора назначения) или для слияния элементов данных в регистр назначения.
Также маски могут использоваться для выборочного чтения из памяти и запись в память элементов векторов, для аккумулирования результатов логических операций над элементами векторов.
Данная уникальная возможность набора инструкций AVX-512 обеспечивает реализацию предикатного режима исполнения \cite{Volkonsky2003VecPred}, который поддержан в таких архитектурах, как ARM или «Эльбрус» \cite{Kim2013VecElb}.
Наличие предикатного режима исполнения позволяет применять оптимизацию слияния ветвей исполнения и, таким образом, избавляться от лишних операций передачи управления, что помогает создавать высокоэффективный параллельный код.

Из других важных особенностей набора инструкций AVX-512 можно отметить операции множественного чтения элементов векторов, расположенных в памяти с произвольными смещениями от базового адреса, а также аналогичные операции записи элементов векторов в память с произвольными смещениями (операции gather/scatter).
Хотя эти операции крайне медленные, они в некоторых случаях помогают существенно упростить логику векторизованного кода.
Также следует отметить большое разнообразие различных операций перестановки, перемешивания, дублирования, пересылки элементов векторов, что позволяет произвольным образом менять порядок обработки данных.
Также существенное ускорение способны принести комбинированные операции, объединяющие операцию умножения и сложения в одну операцию.

По схеме работы можно выделить несколько групп операций AVX-512.
Упакованные операции с одним операндом zmm (512-битный вектор) и одним результатом zmm получают на вход один вектор и применяют к каждому его элементу конкретную функцию, получая результат того же размера, который по маске записывается в выходной вектор.
Примерами таких операция является получение абсолютного значения, извлечение корня, округление, операции сдвигов и другие.
Упакованные операции с двумя операндами zmm и одним результатом zmm отличаются только тем, что применяемая функция является бинарной.
К данной группе относятся операции поэлементного сложения, вычитания, умножения, деления, сдвига на переменное количество разрядов и другие.
Упакованные операции с двумя операндами zmm и результатом маской выполняют поэлементное сравнение двух векторов.
Операции конвертации предназначены для преобразования элементов вектора из одного формата в другой, к ним относятся наборы команд cvt и pack.
Упакованные комбинированные операции принимают на вход сразу три zmm вектора $a$, $b$, $c$ и поэлементно вычисляют значения вида $\pm a \cdot b \pm c$, которые по маске записываются в выходной вектор.
Операции перестановок не выполняют арифметических действий, а только переставляют части вектора в произвольном порядке, определяемом типом операции и дополнительными параметрами.
Данная группа представлена большим набором разнообразных операций unpck, shuf, align, blend, perm.
Операции пересылок предназначены для перемещения последовательных данных между регистрами, а также между памятью и регистром.
Поддержаны также операции пересылки элементов данных, расположенных не последовательно, а с произвольными смещениями от заданного базового адреса в памяти (операции gather и scatter), а также операции пересылки с дублированием элементов, позволяющие переместить одно значение сразу в несколько элементов вектора.
Операции предварительной подкачки данных используются для того, чтобы увеличить вероятность того, что к моменту исполнения команды данные уже будут в кэше.
Кроме того, поддержаны другие операции с более сложной логикой, среди которых определение класса вещественного числа, реализация логических функций от трех аргументов, операции определения конфликтов и другие

Для упрощения применения векторных инструкций при оптимизации программного кода для компилятора icc разработаны специальные функции-интринсики (они определены в заголовочном файле immintrin.h) \cite{IntelIntrinsicsGuide}.
Эти функции покрывают не все множество инструкций AVX-512, однако избавляют от необходимости вручную писать ассемблерный код.
Вместо этого предоставляется возможность оперировать встроенными типами данных для 512-битных векторов и использовать их при работе с функциями-инстринсиками как обычные базовые типы (при построении компилятором исполняемого кода для этих типов данных будут использованы регистры zmm).
Некоторые функции-инстринсики соответствуют не одной отдельной команде, а целой последовательности, как например группа функций reduce, другие же просто раскрываются в вызов библиотечной функции (например, тригонометрические функции).
Из множества интринсиков можно выделить следующие группы функций, схожие по структуре.
Функции swizzle, shuffle, permute и permutevar осуществляют перестановку элементов вектора и раскрываются в последовательность операций, в которой присутвует shuf и пересылка по маске.
Для большего числа операций AVX-512 реализованы соответствующие инстринсики, раскрывающиеся в одну конкретную операцию.
Среди них арифметические операции, побитовые операции, операции чтения из памяти и записи в память, операции конвертации, слияние двух векторов, нахождение обратных значений, получение минимума и максимума из двух значений, операции сравнения, операции с масками, комбинированные операции и другие.
