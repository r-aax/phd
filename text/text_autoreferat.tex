\documentclass[a4paper,14pt]{extarticle}                     % тип документа с размером шрифта 14pt

%---------------------------------------------------------------------------------------------------

%\usepackage{times}                                          % использование Times New Roman
                                                             %     (почему-то сносит все форматирование)
\usepackage[top=2cm,left=3cm,right=1cm,bottom=2cm]{geometry} % размеры полей
\usepackage[]{inputenc}                                      % эта строка нужна, чтобы документ открывался в редакторе MikTex
\usepackage[T2A]{fontenc}                                    % для поддержки русского языка
\usepackage[russian]{babel}                                  % включение русского языка
\usepackage{amsmath,amsthm,amscd,amsfonts,amssymb}           % специальные символы и т.п.
\usepackage{mathrsfs}                                        % специальные символы
\usepackage{indentfirst}                                     % отступ для начала абзаца
\usepackage{textcomp}                                        % текст в формулах
\usepackage{graphicx}                                        % подключение графики
\usepackage{listings}                                        % печать листингов
\usepackage{xcolor}                                          % использование цветов
%\usepackage{caption2}                                        % для изменения стиля подписи рисунков
                                                             %     (приводит к warning-у, так что использовать только по необходимости)
\usepackage{verbatim}                                        % использование дополнительных возможностей verbatim           
\usepackage{fancybox}                                        % использование расширенного Verbatim
\usepackage[linesnumbered,boxed]{algorithm2e}                % оформление алгоритмов
\usepackage{booktabs}                                        % поддержка таблиц
\usepackage{makecell}                                        % для перевода строки внутри ячейки таблицы
\usepackage{ulem}                                            % волнистая черта снизу
\usepackage{textcomp}                                        % для коррекции положения тильды
\usepackage{longtable}                                       % многострочные таблицы
\usepackage{morefloats}                                      % подключить большее количество формул
\usepackage[section]{placeins}                               % сброс обработки флотов в конце страницы
\usepackage{float}                                           % расположение флотов прямо тут
\usepackage{setspace}                                        % чтобы менять междустрочный интервал с подписях
\usepackage{subcaption}                                      % подпись к каждому подрисунку
\usepackage{enumitem}

%---------------------------------------------------------------------------------------------------

\lstset{
aboveskip=15pt,
belowskip=15pt,
belowcaptionskip=10pt,
language={[ANSI]C++},
basewidth=0.5em,
xleftmargin=20pt,
xrightmargin=20pt,
basicstyle=\linespread{0.8}\small\ttfamily,           % 0.8 - уменьшение расстояния между строк
                                                             % linespread должен идти первым 
keywordstyle=\color[rgb]{0,0,1},
numbers=left,
numberstyle=\tiny,
stepnumber=1,
numbersep=10pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=trBL,
tabsize=2,
captionpos=t,
breaklines=false,
breakatwhitespace=false,
escapeinside={\%*}{*)}
}

%---------------------------------------------------------------------------------------------------

%\renewcommand{\GenericWarning}[2]{\GenericError{#1}{#2}{}{This warning has been turned into a fatal error.}} % Предупреждения -> ошибки.
\newcommand{\textapprox}{\raisebox{0.5ex}{\texttildelow}}    % положение тильды
\renewcommand{\baselinestretch}{1.0}                         % полуторный отступ между строк
%\renewcommand{\captionlabeldelim}{.}                         % разделитель между номером рисунка и названием
%\numberwithin{equation}{section}                             % нумерация формул по секциям
%\numberwithin{figure}{section}                               % нумерация картинок по секциям
%\numberwithin{table}{section}                                % нумерация таблиц по секциям
\theoremstyle{plain}                                         % стиль теорем
\newtheorem{theorem}{Теорема}[section]                       % теорема
\newtheorem{lemma}{Лемма}[section]                           % лемма
\newtheorem{definition}{Определение}[section]                % определение
%\numberwithin{theorem}{section}                              % нумерация теорем по секциям
%\numberwithin{lemma}{section}                                % нумерация лемм по секциям
%\numberwithin{definition}{section}                           % нумерация определений по секциям
\newcommand{\sgn}{\mathop{\mathrm{sgn}}\nolimits}
\renewcommand{\thesubfigure}{\asbuk{subfigure}}

%---------------------------------------------------------------------------------------------------

%\captionstyle{center}
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}
\setlist[itemize]{nosep}       % no extra separation
\setlist[enumerate]{nosep}
\setlist[itemize]{nolistsep}       % no extra separation
\setlist[enumerate]{nolistsep}
\setlist[itemize]{noitemsep}       % no extra separation
\setlist[enumerate]{noitemsep}
\setlist[itemize]{topsep=0pt}  % no top separation
\setlist[enumerate]{topsep=0pt}

%---------------------------------------------------------------------------------------------------

\begin{document}

\numberwithin{lstlisting}{section}                           % нумерация листингов по секциям
                                                             % определяем тут, так как счетчик листинга до begin{document}
                                                             % еще не существует
                                                             % https://tex.stackexchange.com/questions/441618/how-to-number-the-listings-within-sections

\title{Проект автореферата на диссертацию по теме <<Повышение эффективности высокопроизводительных вычислений на поверхностных расчетных сетках с изменяемой геометрией>>}
\author{Рыбаков~А.~А.}
\date{22.08.2025}
\maketitle
\thispagestyle{empty}                                        % не нумеруем первую страницу

%---------------------------------------------------------------------------------------------------

\newpage
\subsection*{Общая характеристика работы}

\paragraph{Актуальность}

\

Высокопроизводительные вычисления являются неотъемлемой составляющей научных исследований, промышленных разработок и бизнеса.
Использование высокопроизводительных вычислительных систем находит широкое применение во всех сферах деятельности человека.
Суперкомпьютерные вычисления являются основой для развития передовых технологий проектирования и создания высокотехнологичной продукции.
Суперкомпьютерные вычисления применяются в авиационной и космической промышленности, автомобилестроении, проектировании образцов вооружения, разработке новых материалов, моделировании энергетических объектов и месторождений, медицине, животноводстве и растениеводстве, обеспечении кибербезопасности, исследовании природных процессов и экосистем.
Сферы применениия суперкомпьютерных вычислений отражают основные приоритеты научно-техноло-гического развития Российской Федерации, развитие суперкомпьютерных технологий необходимо для обеспечения места России среди мировых технологических лидеров, поэтому вопросы создания и эффективного использования высокопроизводительных вычислительных систем являются актуальными.

Наиболее ресурсоемкие научно-технические задачи, связанные с суперкомпьютерными расчетами, представляют собой моделирование различных физических процессов в трехмерном пространстве.
К таким задачам относятся моделирование процессов газовой динамики, электромагнетизма, термодинамики и многих других.
При этом вычисления проводятся, как правило, с использованием расчетных сеток, которые могут описывать как область трехмерного пространства (объемные расчетные сетки), так и некоторую расположенную в трехмерном пространстве поверхность (поверхностные расчетные сетки.
Настоящая работа посвящена оптимизации суперкомпьютерных вычислений для моделирования процесса обледенения поверхности, хотя результаты работы применимы и к другим предметным областям.
Вычисления по моделированию обледенения проводятся на поверхностных неструктурированных расчетных сетках, описывающих поверхность в трехмерном пространстве и способных изменять свою геометрию в процессе проведения расчетов, а также на объемных расчетных сетках, описывающих область пространства вокруг этой поверхности.

Задача моделирования обледенения летательных аппаратов является критически важной для обеспечения безопасности полетов.
Известны случаи, когда обледенение несущих частей и силовых установок летательных аппаратов приводили к авиакатастрофам с большим количеством человеческих жертв\footnote[1]{Катастрофа Ан-148 в Подмосковье в 2018 г., катастрофа DC-8 в Канаде в 1985 г., катастрофа Ту-134 под Минском в 1985 г., катастрофа MD-83 в Мали в 2014 г., катастрофа Ан-24 в Бугульме в 1991 г.}, что свидетельствует о важности этой задачи и востребованности результатов ее решения.
Требования и рекомендации к процессам проектирования, разработки и сертификации авиационных систем с учетом эксплуатации в режимах обледенения зафиксированы во многих нормативных документах\footnote[2]{14 CFR -- Part 25 (Appendix C, O), Part 29 (Appendix C), Part 33 (Appendix D); FAA AC 25-28; ARP 4754; ARP 4761; Р 4761; ISO 11076:2020; Doc 9640; FAA Report ADS-4; FAA Report RD-77-76; НЛГ БАС-СТ.}.

Задача обледенения поверхности является комплексной, для получения адекватной картины ледообразования необходимо учитывать множество сопряженных процессов, включая обтекание тела, выпадение на поверхность влаги и ледяных кристаллов из окружающего потока, взаимодействие выпадающего вещества с поверхностью, течение жидкости по поверхности в виде тонкой пленки или отдельных нитей, теплопроводность на поверхности, а также через слой жидкости и льда и многие другие процессы.
В процессе образования слоя льда меняется геометрия рассматриваемой поверхности, так как форма образовавшихся ледяных наростов влияет на все связанные процессы, что приводит к необходимости перестроения расчетных сеток.

В пользу актуальности и востребованности исследований и разработок в области моделирования обледенения свидетельствует большое количество существующих и разрабатываемых программных пакетов для решения этой задачи.
Среди зарубежного программного обеспечения для моделирования процесса ледообразования лидером является пакет инженерного проектирования ANSYS (включающий в себя модули FENSAP-ICE, DROP3D, ICE3D).
Кроме него можно назвать и другие расчетные коды, например, LEWICE, AIPAC, ONERA, TRAJICE и другие.
В России в настоящее время также разрабатывается набор алгоритмов и программного обеспечения для моделирования процесса ледообразования.
В их числе можно назвать разработку модуля iceFoam как части открытого программного обеспечения OpenFOAM.
Среди коммерческих программных продуктов выделяется модуль IceVision в составе пакета FlowVision, а также решение для моделирования ледяного покрова в составе пакета инженерного анализа ЛОГОС.

Моделирование процесса ледообразования выполняется, как правило, на поверхностных расчетных сетках и состоит из отдельных макроитераций, каждая из которых проходит в два этапа.
На первом этапе итерационно выполняется расчет интенсивности нарастания льда в рамках отдельных ячеек расчетной сетки (интенсивность ледообразования может выражаться в массе накопленного льда в ячейке за временя макроитерации, в скорости нарастания высоты ледяного покрова в узле сетки и в других характеристиках).
Для вычисления интенсивности ледообразования в элементах расчетной сетки существует множество моделей ледообразования, в которых учитываются различные состояния льда, течение жидкой пленки по поверхности, тепловые потоки, выпадение на поверхность влаги, ледяных кристаллов и переохлажденных капель, различные механики плавления и срыва ледяных наростов и многие другие факторы.
На втором этапе моделирования ледяных наростов выполняется перестроение поверхности обледеневающего тела.
При этом перестроение должно выполняться таким образом, чтобы изменение объема рассматриваемого тела соответствовало вычисленному объему накопленного за время макроитерации льда на первом этапе.
После перестроения поверхностной расчетной сетки необходимо произвести пересчет поля скоростей вокруг нее, так как изменение геометрии поверхности существенным образом влияет на картину обтекания.
После пересчета поля скоростей моделирование процесса обледенения может быть продолжено.

Моделирование процесса ледообразования является крайне ресурсоемким процессом, включающем в себя не только выполнение вычислений на поверхностной расчетной сетке, но и постоянное перестроение поверхностной сетки и пересчет поля скоростей в окружающем пространстве.
Перестроение поверхностной расчетной сетки, адекватно описывающей геометрию образующихся ледяных наростов, должно отвечать критериям точности перестроения и устойчивости.
Возникновение дефектов сетки, таких как острые пики и изломы, трещины и впадины, самопересечения сетки, могут привести к аварийному завершению процесса расчета и необходимости его перезапуска, что приводит к дополнительному потреблению вычислительных ресурсов. 
Для выполнения моделирования образования ледяных наростов на значимом промежутке времени требуется использование существенных суперкомпьютерных ресурсов и применение методов для оптимизации вычислений на поверхностных и объемных расчетных сетках на всех уровнях распараллеливания: в модели с передачей сообщений, на общей памяти и на уровне отдельных инструкций.

\paragraph{Цель и задачи работы}

\

Целью работы является повышение эффективности высокопроизводительных вычислений на поверхностных расчетных сетках с изменяемой геометрией в применении к задаче моделирования обледенения поверхности.

Для достижения поставленной цели в диссертационной работе необходимо решить следующие \textbf{задачи}:
\begin{enumerate}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
\item Разработать и реализовать метод перестроения поверхностной расчетной сетки, обладающий способностью устранения мелких дефектов, а также разработать и реализовать методы устранения самопересечений поверхностной расчетной сетки для устойчивого выполнения вычислений в задаче моделирования процесса обледенения.
\item Разработать и реализовать методы повышения эффективности распараллеливания вычислений на поверхностных и объемных расчетных сетках в моделях распараллеливания с передачей сообщений и на общей памяти.
\item Разработать методику повышения производительности суперкомпьютерных приложений с помощью векторизации вычислений и методы векторизации программного кода.
\end{enumerate}

\paragraph{Методология и методы исследования}

\

Математическую основу исследования составляют методы вычислительной геометрии, теории алгоритмов, теории графов, теории вероятностей.
Для замера эффективности использования суперкомпьютерных ресурсов применялись численные эксперименты на суперкомпьютерах Межведомственного суперкомпьютерного центра Российской академии наук и Национального исследовательского центра <<Курчатовский институт>>.

\paragraph{Научная новизна}

\

\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
\item Разработан новый метод перестроения поверхностной неструктурированной расчетной сетки, позволяющий сглаживать дефекты сетки при перестроении (сглаживание острых пиков и владин).
\item Разработаны новые методы устранения самопересечений поверхностной неструктурированной расчетной сетки, основанные на обходе внешней поверхности области распространения льда.
\item Разработан новый алгоритм распределения блоков блочно-структуриро-ванной расчетной сетки по вычислительным процесам с дроблением блоков.
\item Разработан новый алгоритм сглаживания границ между доменами поверхностной неструктурированной расчетной сетки.
\item Разработана новая методика векторизации программного кода на основе предстваления кода в виде композиции плоских циклов, разработаны новые алгоритмы векторизации программного кода.
\end{itemize}

\paragraph{Достоверность полученных результатов}

\

Достоверность полученных результатов подтверждается экспериментами на суперкомпьютерах Межведомственного суперкомпьютерного центра Российской академии наук и Национального центра <<Курчатовский институт>> и практикой применения в программном модуле компьютерного моделирования процесса обледенения элементов авиационных силовых установок <<Кристалл>>.

\paragraph{Теоретическая и практическая значимость}

\

Разработанный метод перестроения поверхностной расчетной сетки основан на принципе использования окрестностей геометрических объектов, который может быть применен в других предметных областях.
Разработанные методы устранения самопересечений поверхностной расчетной сетки были разработаны с учетом специфики проблемы моделирования обледенения, хотя могут быть использованы без привязки к ней.
Методы повышения эффективности распараллеливания вычислений в моделях распараллеливания с передачей сообщений, на общей памяти и на уровне отдельных инструкций были разработаны преимущественно без привязки к предметной области и могут быть использованы как отдельные самостоятельные результаты.

Описанные в работе методы и алгоритмы апробированы на суперкомпьютерах Межведомственного суперкомпьютерного центра Российской академии наук и Национального центра <<Курчатовский институт>> и реализованы в рамках инструментов суперкомпьютерного моделирования, на которые оформлены 7 свидетельств о государственной регистрации программы для ЭВМ.
В частности, разработанные в рамках диссертации методы перестроения поверхностной неструктурированной расчетной сетки и устранения самопересечений, а также методы повышения эффективности суперкомпьютерных расчетов на ней нашли свое отражение в программном модуле компьютерного моделирования процесса обледенения элементов авиационных силовых установок <<Кристалл>>.

\paragraph{Положения, выносимые на защиту}
\begin{enumerate}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
\item Разработанный метод перестроения поверхностной неструктурированной расчетной сетки обеспечивает сглаживание дефектов сетки при перестроении и обладает приемлемой точностью перестроения.
\item Разработанный метод устранения самопересечений поверхностной не-структурированной расчетной сетки позволяет удалять самопересечения сетки, обеспечивая устойчивость выполнения расчетов в задаче моделирования ледообразования.
\item Разработанная архитектура объемной блочно-структурированной расчетной сетки и алгоритм распределения вычислительной нагрузки с дроблением блоков обеспечивают возможность равномерного распределения вычислительной нагрузки при распараллеливании вычислений в модели с передачей сообщений.
\item Разработанный алгоритм сглаживания границ между доменами поверхностной неструктурированной расчетной сетки позволяет найти точное решение задачи о сглаживании границ между доменами, уменьшая объем пересылаемых данных во время межпроцессных обменов при распараллеливании вычислений в модели с передачей сообщений.
\item Разработанная методика векторизации программного кода, принципы организации программного расчетного кода и методы повышения эффективности векторизации обеспечивают кратное ускорение векторного кода на широком классе приложений для высокопроизводительных вычислений.
\end{enumerate}

\paragraph{Соответствие паспорту специальности}

\

Диссертация соответствует следующим пунктам паспорта специальности 2.3.5. <<Математическое и программное обеспечение вычислительных систем, комплексов и компьютерных сетей>>:
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
\item модели, методы и алгоритмы проектирования, анализа, трансформации, верификации и тестирования программ и программных систем;
\item модели, методы, архитектуры, алгоритмы, языки и программные инструменты организации взаимодействия программ и программных систем;
\item модели и методы создания программ и программных систем для параллельной и распределенной обработки данных, языки и инструментальные средства параллельного программирования.
\end{itemize}

\paragraph{Апробация диссертации}

\

Материалы диссертации докладывались на следующих конференциях и семинарах:
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
\item V Национальный Суперкомпьютерный Форум (НСКФ-2016), Россия, Переславль-Залесский, Институт программных систем им. А.~К.~Айламазяна, 29 ноября -- 2 декабря 2016 г.
\item VII Национальный Суперкомпьютерный Форум (НСКФ-2018), Россия, Переславль-Залесский, Институт программных систем им. А.~К.~Айламазяна, 27-30 ноября 2018 г.
\item X Национальный Суперкомпьютерный Форум (НСКФ-2021), Россия, Переславль-Залесский, Институт программных систем им. А.~К.~Айламазяна, 30 ноября -- 3 декабря 2021 г.
\item I Международная научная конференция <<Конвергентные когнитивно-информационные технологии>>, Россия, Москва, Московский государственный университет им. М.~В.~Ломоносова, 25-26 ноября 2016 г.
\item III Международная научная конференция <<Конвергентные когнитивно-информационные технологии>>, Россия, Москва, Московский государственный университет им. М.~В.~Ломоносова, 22-25 ноября 2018 г.
\item XVI Международная конференция <<Супервычисления и математическое моделирование>>, Россия, Саров, Российский федеральный ядерный центр -- Всероссийский научно-исследовательский институт экспериментальной физики, 3-7 октября 2016 г.
\item VI всероссийская конференция <<Вычислительный эксперимент в аэроакустике>>, Россия, Светлогорск, организатор -- Институт прикладной математики им. М.~В.~Келдыша РАН, 19-24 сентября 2016 г.
\item Слет разработчиков отечественных CFD кодов (CFD Weekend 2023), Россия, Москва, Институт прикладной математики им. М.~В.~Келдыша, 9-10 декабря 2023 г.
\item Слет разработчиков отечественных CFD кодов (CFD Weekend 2022), Россия, Москва, Институт прикладной математики им. М.~В.~Келдыша, 3-4 декабря 2022 г.
\item The Intel Xeon Phi users group Russia annual meeting (IXPUG Russia-2017), // Joint Supercomputer Center of the Russian Academy of Sciences (JSCC RAS), Russia, Moscow, 1-2 June 2017.
\end{itemize}

\paragraph{Личный вклад автора} 

\

Результаты диссертации были получены соискателем лично или при его руководстве в научно-исследовательских работах по Программам фундаментальных научных исследований государственных академий наук, Программам фундаментальных исследований президиума РАН, и проектам РФФИ.
Все выносимые на защиту положения получены автором лично.

\paragraph{Публикации} 

\

По теме диссертации автором опубликовано 35 печатных работ, из них 24 работы [1-24] опубликованы в журналах, рекомендованных ВАК (в том числе -- 5 работ [1, 3, 4, 6, 22] -- в журналах, входящих в список К1 перечня ВАК), 15 работ [1, 3, 4, 6-8, 11, 14-19, 22, 23] -- в журналах, входящих в индекс RSCI, 7 работ [7, 8, 11, 14, 17-19] -- в журналах, индексируемых в международных базах научных изданий Web of Science и Scopus.
По теме диссертации получено 7 свидетельств о государственной регистрации программы для ЭВМ.

\paragraph{Структура и объем работы} 

\

Диссертация состоит из введения, пяти глав и заключения.
Содержание работы изложено на X страницах машинописного текста.
Список использованных источников составляет X наименований.

%---------------------------------------------------------------------------------------------------

\newpage
\subsection*{Краткое содержание работы}

\textbf{Во введении} обоснована актуальность работы, сформулированы цель и задачи работы, приведены научная новизна, практическая значимость полученных результатов и защищаемые положения, рассмотрена структура диссертации. 

%---------------------------------------------------------------------------------------------------

\textbf{Первая глава} посвящена задаче перестроения поверхностной сетки в двумерном случае.
\textit{Двумерной поверхностной сеткой} будем называть ломаную без самопересечений, состоящую из $n$ ячеек-отрезков $F_i$ длины $l_i$ ($0 \le i < n)$. Инцидентными узлами ячейки $F_i$ являются узлы $N_i$, $N_{i + 1}$. Для ячейки $F_i$ определена внешняя единичная нормаль $\overline{n}_i^F$.
Для узла $N_i$ определена единичная нормаль $\overline{n}_i^N = (\overline{n}_{i-1}^F + \overline{n}_i^F) / |\overline{n}_{i-1}^F + \overline{n}_i^F|$, лежащая на биссектрисе телесного угла между ячейками $F_{i - 1}$ и $F_i$, обозначаемого $2 \phi_i$ (рис.~\ref{fig:remesh_2d}~а).

\begin{figure}[ht]
\centering
\begin{tabular}{ll}
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=0.75\columnwidth]{pics/text_1_remesh_2d/grid_normals.pdf}\caption{обозначения}\end{subfigure} &
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=0.75\columnwidth]{pics/text_1_remesh_2d/remesh_rectangles.pdf}\caption{метод прямоугольников}\end{subfigure} \\
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=0.75\columnwidth]{pics/text_1_remesh_2d/remesh_trapeziums.pdf}\caption{метод трапеций}\end{subfigure} &
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=0.75\columnwidth]{pics/text_1_remesh_2d/remesh_okrestnost.pdf}\caption{метод окрестностей}\end{subfigure}
\end{tabular}
\singlespacing
\caption{Перестроение двумерной поверхностной сетки.}
\label{fig:remesh_2d}
\end{figure}

Для моделирования процесса ледообразования центральной задачей перестроения поверхностной сетки является определение новых положений узлов $N'_i$, при которых площадь $S_i = S_{N_iN'_iN'_{i+1}N_{i+1}}$, заметаемая ячейкой $F_i$, как можно меньше отличалась от \textit{целевой площади} $T_i = l_i H_i$, где $H_i$ -- вычисленная высота ледяного покрова в ячейке $F_i$.
Задача рассматривается при фиксированных направлениях смещения узлов $\overline{n}_i^N$, то есть требуется определить только величины смещения узлов $h_i$.
Для оценки отклонения заметаемой площади от целевой используются обозначения $\Delta_i = S_i - T_i$, $\delta_i = \Delta_i / T_i$.

%----------------------------------

В п.~1.1 задача определения величин смещений узлов $h_i$ рассматривается в общем виде, и она может быть решена с помощью метода градиентного спуска для нахождения минимума функции
\begin{equation*}
	D(\overline{h}) = \sum_{i = 0}^{n - 1}{\Delta_i^2} = \sum_{i = 0}^{n - 1}{ \left( \frac{ l_i(h_i \sin \phi_i + h_{i + 1} \sin \phi_{i+1}) - h_ih_{i + 1} \sin(\phi_i + \phi_{i+1}) }{2} - T_i \right)^2}
\end{equation*}

Так как решение задачи о перестроении сетки методом градиентного спуска оказывается слишком требовательным к вычислительным ресурсам, а также качество решения зачастую оказывается неудовлетворительным при попадании в локальные минимумы, то рассматриваются приближенные методы, основанные на представлении целевой площади в виде примитивных геометрических фигур.

%----------------------------------

В п.~1.2 рассматриваются приближенные методы перестроения поверхностной сетки.

В первом методе рассматривается приближение, при котором целевая площадь для $i$-ой ячейки представлена прямоугольником со сторонами $l_i$ и $H_i$ и величина смещения узла определяется как $h_i = (H_{i - 1} + H_i)/2$ (рис.~\ref{fig:remesh_2d}~б).
Заметаемая $i$-ой ячейкой площадь при использовании этого метода, называемого \textit{методом прямоугольников}, обозначается $S_i^r$, также используются обозначения $\Delta_i^r = S_i^r - T_i$, $\delta_i^r = \Delta_i^r / T_i$.

В качестве второго метода рассматривается \textit{метод трапеций} (рис.~\ref{fig:remesh_2d}~в), в котором целевая площадь для $i$-ой ячейки представлена трапецией с площадью $T_i$ и боковыми сторонами, лежащими на направлениях $\overline{n}_i^N$, $\overline{n}_{i + 1}^N$, высота этой трапеции обозначена $H_i^t$.
После построения трапеций для всех ячеек сетки у каждого узла появляются две новые потенциальные позиции для сдвига (образованные ячейкой слева и ячейкой справа).
В качестве финальной новой позиции выбирается их среднее значение, и $h_i = (H_{i - 1}^t + H_i^t) / (2 \sin \phi_i)$.
Заметаемая $i$-ой ячейкой площадь при использовании метода трапеций обозначается $S_i^t$, также используются обозначения $\Delta_i^t = S_i^t - T_i$, $\delta_i^t = \Delta_i^t / T_i$.

Предлагается новый метод перестроения, называемый \textit{методом окрестностей}.
В этом методе рассматривается \textit{область распространения льда (ОРЛ)} сетки (рис.~\ref{fig:remesh_2d}~г).
При этом ОРЛ узла $N_i$ считается круг с центром $N_i$ и радиусом $r_i = (H_{i - 1} + H_i)/2$.
Под ОРЛ ячейки понимается выпуклая оболочка ОРЛ ее узлов и ограниченная ей область плоскости.
ОРЛ сетки -- объединение ОРЛ всех ее ячеек.
В качестве нового положения узла $N_i$ берется пересечение направления $\overline{n}_i^N$ и границы ОРЛ сетки.
Заметаемая $i$-ой ячейкой площадь при использовании метода окрестностей обозначается $S_i^o$, также используются обозначения $\Delta_i^o = S_i^o - T_i$, $\delta_i^o = \Delta_i^o / T_i$.

%----------------------------------

В п.~1.3 приводится аналитическая оценка точности приближенных методов перестроения.
Оценка проводится для модельной расчетной сетки, которая удовлетворяет следующим требованиям.
Все ячейки сетки одинаковые и имеют длину $l$.
Для любой ячейки $AB$ и ее соседей $A_2A$ и $BB_2$ углы $\angle (\overline{BA}, \overline{AA_2})$ и $\angle (\overline{AB}, \overline{BB_2})$ являются постоянной величиной и равны $\alpha$.
Величины смещений ячеек $A_2A$, $AB$ и $BB_2$ равны $H_{i - 1}$, $H_i$ и $H_{i + 1}$ соответственно.
Величины смещения узлов равны $h_i = AA_1$, $h_{i + 1} = BB_1$, также $\lambda = l / (2 \sin \frac{\alpha}{2})$.
Оценка проводится для постоянного изменения смещения ячейки $\Delta H = H_i - H_{i - 1} = H_{i + 1} - H_i$.

\begin{figure}[ht]
\centering
\begin{tabular}{cc}
\begin{subfigure}{0.4\textwidth}\centering\includegraphics[width=1.0\columnwidth]{pics/text_1_remesh_2d/theoretical.pdf}\caption{выпуклая сетка}\end{subfigure} &
\begin{subfigure}{0.4\textwidth}\centering\includegraphics[width=1.0\columnwidth]{pics/text_1_remesh_2d/theoretical_concave.pdf}\caption{вогнутая сетка}\end{subfigure}
\end{tabular}
\singlespacing
\caption{Оценка точности перестроения приближенных методов.}
\label{fig:remesh_2d_accuracy}
\end{figure}

Для выпуклой и вогнутой сеток в обозначенных условиях приводятся следующие утверждения для вычисления заметаемой площади.

\textbf{Лемма.} \textit{Для ячейки выпуклой сетки площадь, заметаемая $i$-ой ячейкой, равна $S_i = \frac{1}{2} \sin \alpha \left( \lambda(h_i + h_{i+1}) + h_ih_{i+1} \right)$ (рис.~\ref{fig:remesh_2d_accuracy}~а).}

\textbf{Лемма.} \textit{Для ячейки вогнутой сетки $S_i = \frac{1}{2} \sin \alpha \left( \lambda(h_i + h_{i+1}) - h_ih_{i+1} \right)$ при выполнении условия $\max(h_i, h_{i+1}) \le \lambda$ (рис.~\ref{fig:remesh_2d_accuracy}~б).}

\begin{figure}[ht]
\centering
\includegraphics[width=0.45\textwidth]{pics/text_1_remesh_2d/remesh_3d_chart.png}
\singlespacing
\caption{Графики $\delta_i^r(\alpha, \frac{\Delta H}{l})$, $\delta_i^t(\alpha, \frac{\Delta H}{l})$, $\delta_i^o(\alpha, \frac{\Delta H}{l})$ при $H = \frac{l}{2}$.}
\label{fig:text_1_remesh_3d_main_chart}
\end{figure}

Формулу $S_i = \frac{1}{2} \sin \alpha \left( \lambda(h_i + h_{i+1}) + h_ih_{i+1} \right)$ можно использовать как для выпуклой сетки, так и для вогнутой (приняв для вогнутой сетки $\alpha < 0$).
Для трех рассмотренных методов перестроения получены выражения для $h_i$ в аналитическом виде, получены зависимости $\delta_i^r(\alpha, \frac{\Delta H}{l})$, $\delta_i^t(\alpha, \frac{\Delta H}{l})$, $\delta_i^o(\alpha, \frac{\Delta H}{l})$ и проведен их анализ, представленный на рис.~\ref{fig:text_1_remesh_3d_main_chart} и рис.~\ref{fig:text_1_remesh_fix_alfa_chart}.
Из рис.~\ref{fig:text_1_remesh_3d_main_chart} можно отметить, что при $\Delta H = 0$ метод трапеций абсолютно точен.
Также при $\Delta H = 0$ отклонения $\delta_i^r$ и $\delta_i^o$ близки.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{pics/text_1_remesh_2d/remesh_fix_alfa_chart.png}
\singlespacing
\caption{Графики $\delta_i^r(\frac{\Delta H}{l})$, $\delta_i^t(\frac{\Delta H}{l})$, $\delta_i^o(\frac{\Delta H}{l})$ при $\alpha = \pm 0,5$.}
\label{fig:text_1_remesh_fix_alfa_chart}
\end{figure}

Дополнительно приводятся зависимости $\delta_i^r$, $\delta_i^t$, $\delta_i^o$ от $\frac{\Delta H}{l}$ при фиксированных значениях $\alpha = \pm 0,5$ (рис.~\ref{fig:text_1_remesh_fix_alfa_chart}).
Из рисунка видно, что метод трапеций при небольших значениях $\frac{\Delta H}{l}$ наиболее точен, а точность методов прямоугольников и окрестностей достаточно близки.

%----------------------------------

В п.~1.4 приведены оценки сглаживания острых пиков и впадин для рассмотренных методов перестроения сетки (методы прямоугольников, трапеций и окрестностей).
Для этого рассматривается расчетная сетка с одинаковыми ячейками-отрезками длины $l$.
Для оценки сглаживания острых пиков считается, что сетка является абсолютно плоской за исключением двух соседних ячеек, которые образуют острый пик с углом $2 \alpha$.
Для оценки сглаживания впадин считается, что сетка является абсолютно плоской за исключением двух соседних ячеек, которые образуют впадину с углом $2 \alpha$ (рис.~\ref{fig:text_1_remesh_2d_peak_cavern_general}).

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{./pics/text_1_remesh_2d/peak-cavern-general.pdf}
\singlespacing
\caption{Оценка сглаживания угла при остром пике и при впадине.}
\label{fig:text_1_remesh_2d_peak_cavern_general}
\end{figure}

\textbf{Лемма.} \textit{Сглаженный угол при остром пике выражается как $\hat{\alpha}_1(h_A, h_B) = \arctg \frac{l \sin \alpha + h_B \cos \gamma}{l \cos \alpha + h_A - h_B \sin \gamma}$ (рис.~\ref{fig:text_1_remesh_2d_peak_cavern_general} слева).}

\textbf{Лемма.} \textit{Сглаженный угол при впадине выражается как $\check{\alpha}_1(h_A, h_B) = \arctg \frac{l \sin \alpha - h_B \cos \gamma}{l \cos \alpha - h_A + h_B \sin \gamma}$ при условии $\arcsin \frac{h_B \left( \sqrt{8 l^2 + h_B^2} - h_B \right)}{4 l^2} \le \alpha \le \arccos \frac{h_A}{l}$ (рис.~\ref{fig:text_1_remesh_2d_peak_cavern_general} справа).}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_1_remesh_2d/peak-methods-chart.png}
\singlespacing
\caption{Сравнение сглаживания угла при остром пике.}
\label{fig:text_1_remesh_2d_peak_methods_chart}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_1_remesh_2d/cavern-methods-chart.png}
\singlespacing
\caption{Сравнение сглаживания угла при впадине.}
\label{fig:text_1_remesh_2d_cavern_methods_chart}
\end{figure}

На рис.~\ref{fig:text_1_remesh_2d_peak_methods_chart} приведены графики сравнения методов перестроения в применении к сглаживанию острых пиков при $H = \frac{l}{4}$.
На графике слева показана зависимость изменения сглаженного угла $\hat{\alpha}_1$ от $\alpha$.
На графике справа показана эффективность сглаживания, выраженная формулой $\frac{2 \hat{\alpha}_1 - 2 \alpha}{\pi - 2 \alpha}$ (значение 1 означает полное сглаживание пика до угла $\hat{\alpha}_1 = \frac{\pi}{2}$).
Наиболее эффективное сглаживание угла $\alpha$ обеспечивает метод окрестностей.
Использование метода трапеций для малых углов $\alpha$ приводит к неконтролируемому росту $h_A$, что делает применение этого метода неприемлемым.

На рис.~\ref{fig:text_1_remesh_2d_cavern_methods_chart} приведены графики сравнения методов перестрения в применении к сглаживанию впадин при $H = \frac{l}{4}$.
На графике слева показана зависимость изменения сглаженного угла $\check{\alpha}_1$ от $\alpha$, а справа -- эффективность сглаживания $\frac{2 \check{\alpha}_1 - 2 \alpha}{\pi - 2 \alpha}$.
Метод прямоугольников не сглаживает угол, а наоборот, делает его еще более острым (значение эффективности сглаживания меньше нуля).
Метод трапеций показывает лучшую эффективность сглаживания, но с меньшей областью применимости.

Из приведенных оценок на рис.~\ref{fig:text_1_remesh_2d_peak_methods_chart} и рис.~\ref{fig:text_1_remesh_2d_cavern_methods_chart} можно сделать вывод, что метод окрестностей перестроения является оптимальным с точки зрения точности перестроения и способности сглаживания дефектов сетки.

%---------------------------------------------------------------------------------------------------

\newpage
\textbf{Вторая глава} посвящена задаче перестроения поверхностной сетки в трехмерном случае.

Рассматривается трехмерная поверхностная неструктурированная сетка с треугольными ячейками.
Сетка описывает двустороннюю поверхность без самопересечений, в которой у каждого ребра не более двух инцидентных ячеек.
Для каждой ячейки $F$ определена внешняя единичная нормаль $\overline{n}_F^F$.
Единичная нормаль для узла $N$ определяется аналогично двумерному случаю $\overline{n}_N^N = \sum_{F \in \mathscr{F}(N)}{\overline{n}_F^F} / |\sum_{F \in \mathscr{F}(N)}{\overline{n}_F^F}|$, где $\mathscr{F}(N)$ -- множество ячеек, инцидентных $N$.

%----------------------------------

В п.~2.1 рассматривается постановка задачи перестроения поверхностной неструктурированной расчетной сетки в трехмерном случае при фиксированных направлениях смещения узлов, совпадающих с $\overline{n}^N$.
Задача рассматривается в постановке, когда в каждой ячейке $F$ сетки известен объем накопленного льда $V_F$.
Для каждого узла сетки $N$ требуется найти его новое положение в пространстве $N'$, чтобы для каждой ячейки с узлами $ABC$ объем пространства, ограниченный фигурой $ABCA'B'C'$ соответствовал объему льда, накопленному в этой ячейке.
Таким образом, поставновка задачи в трехмерном случае аналогично двумерной постановке.

\begin{figure}[h]
\centering
\begin{tabular}{ll}
\begin{subfigure}{0.4\textwidth}\centering\includegraphics[width=1.0\columnwidth]{pics/text_1_remesh_3d/pic_classical_methods_prisms.pdf}\caption{метод призм}\end{subfigure} &
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=1.0\columnwidth]{pics/text_1_remesh_3d/pic_classical_methods_pyramids.pdf}\caption{метод пирамид}\end{subfigure}
\end{tabular}
\singlespacing
\caption{Перестроение поверхностной сетки с трехмерном случае.}
\label{fig:text_1_remesh3}
\end{figure}

Для трехмерной постановки рассматриваются классические приближенные методы перестроения, аналогичные двумерному случаю (рис.~\ref{fig:text_1_remesh3}).
В \textit{методе призм} (аналог метода прямоугольников в двумерной постановке) в качестве приближения заметаемого объема рассматривается призма, одним из оснований которой является ячейка.
В \textit{методе пирамид} (аналог метода трапеций в двумерной постановке) в качестве приближения заметаемого объема рассматривается призматоид, одним из оснований которого является ячейка, а боковые стороны направлены вдоль направлений смещения узлов.

Также рассматриваются дополнительные вопросы перестроения поверхностной сетки, включая методы, в которых направления смещения узлов $\overline{n}^N$ могут изменяться.
В частности многослойный метод перестроения, в котором выполнятеся $k$ последовательных шагов перестроения сетки, на каждом из которых решается задача для объема накопленного в ячейке $F$ льда в количестве $V_F/k$.
Рассматриваются метод сглаживания поля нормалей $\overline{n}^N$, $\overline{n}^F$ для предотвращения раннего самопересечения сетки, метод сглаживания высот льда в ячейках для устранения поверхностного шума, а также метод сглаживания сетки, позволяющий перераспределить узлы по поверхности для балансировки размера ячеек\footnote[3]{X.~Tong, D.~Thompson, Q.~Arnoldus, E.~Collins, E.~Luke. Three-dimensional surface evolution and mesh deformation for aircraft icing applications. // Journal of Aircraft, 2017, vol.~54, p.~1047–1063, doi:~10.
2514/1.C033949}.

%----------------------------------

В п.~2.2 предлагается метод окрестностей перестроения поверхностной неструктурированной расчетной сетки в трехмерной постановке.
Рассматривается геометрическая задача определения новых положений узлов расчетной сетки, если для каждого узла $N$ известна скорость образования ледяного покрова $v_N$.
Будем считать, что нарастание льда в любой точке роста льда выполняется одновременно во всех направлениях аналогично принципу Гюйгенса-Френеля распространения волн.
ОРЛ произвольной точки $P$ через промежуток времени $\Delta t$ будет иметь форму шара $Ball(P, v_P\Delta t)$.
Далее будем считать, что мы выполняем расчет новых положений узлов через некоторый фиксированный момент времени $\Delta t$, то есть для каждого узла $N$ известен радиус ОРЛ узла $R_N = v_N \Delta t$.
Радиус ОРЛ внутренней точки $\overline{P}(\beta, \gamma) = \overline{A} + \beta (\overline{B} - \overline{A}) + \gamma (\overline{C} - \overline{A})$ ячейки $ABC$ будем определять как $R(\overline{P}(\beta,\gamma)) = R(\beta,\gamma) = R_A + \beta(R_B - R_A) + \gamma(R_C - R_A) = R_A + \beta R_{AB} + \gamma R_{AC}$, где $\beta \ge 0$, $\gamma \ge 0$, $\beta + \gamma \le 1$.
Тогда ОРЛ ячейки является объединение пучка шаров $\{ Ball(P(\beta, \gamma), R(\beta, \gamma)) \ | \ \beta \ge 0, \ \gamma \ge 0, \ \beta + \gamma \le 1 \}$.
Под ОРЛ сетки будем понимать объединение ОРЛ всех ее ячеек.
В методе окрестностей аналогично двумерному случаю в качестве нового положения узла $N'$ будем брать пересечение направления смещения узла $\overline{n}_N^N$ и границу ОРЛ сетки.

Рассматривается задача нахождения точек пересечения траектории движения узла $A$ ($\overline{P}(\alpha) = \overline{A} + \alpha \overline{D}$, где $\overline{D} = \overline{n}_A^N$ при $\alpha \ge 0$) с ОРЛ ячейки $ABC$.
Эти точки находятся из решения уравнения $|(\overline{A} + \alpha \overline{D}) - \overline{P}(\beta, \gamma)| = R(\beta, \gamma)$ относительно $\alpha$.

Наибольший корень уравнения $|(\overline{A} + \alpha \overline{D}) - \overline{P}(\beta, \gamma)| = R(\beta, \gamma)$ при условии $|\overline{D}| = 1$ выражается следующим образом:
\begin{equation*}
	\begin{aligned}
		& \alpha(\beta, \gamma) = k_{\beta} \beta + k_{\gamma} \gamma + \sqrt{T} \\
		& T = q_{\beta^2} \beta^2 + q_{\gamma^2} \gamma^2 + q_{\beta \gamma} \beta \gamma + q_{\beta} \beta + q_{\gamma} \gamma + q \\
		& k_{\beta} = (\overline{D}, \overline{AB}), \ k_{\gamma} = (\overline{D}, \overline{AC}) \\
		& q_{\beta^2} = (\overline{D}, \overline{AB})^2 - |\overline{AB}|^2 + R_{AB}^2 \\
		& q_{\gamma^2} = (\overline{D}, \overline{AC})^2 - |\overline{AC}|^2 + R_{AC}^2 \\
		& q_{\beta \gamma} = 2 \left( (\overline{D}, \overline{AB}) (\overline{D}, \overline{AC}) - (\overline{AB}, \overline{AC}) + R_{AB}R_{AC} \right) \\
		& q_{\beta} = 2 R_A R_{AB}, \ q_{\gamma} = 2 R_A R_{AC}, \ q = R_A^2
	\end{aligned}
\end{equation*}

Для поиска нового положения узла $A$ относительно ячейки $ABC$ требуется найти максимум выражения $\alpha(\beta, \gamma)$ при условии соблюдения ограничений $\beta \ge 0$, $\gamma \ge 0$, $\beta + \gamma \le 1$ (обозначим это положение $A'(ABC)$, а соответствующее значение $\alpha$ через $\alpha(ABC)$).
Изложенная последовательность действий касается определения смещения узла с учетом только одной инцидентной ячейки.
В общем случае при рассмотрении узла расчетной сетки требуется вычислить смещение этого узла относительно каждой инцидентной ячейки и выбрать среди этих смещений максимальное $\overline{A}' = \overline{A} + \overline{n}_A^N \cdot \max_{F \in \mathscr{F}(A)}{\alpha(F)}$.

Предложенный метод окрестностей перестроения поверхностной неструктурированной расчетной сетки в трехмерном случае, также как и его двумерный аналог, обладает способностью сглаживания дефектов расчетной сетки при приемлемой точности перестроения.
В сочетании с многослойным методом метод окрестностей позволяет избежать появления острых пиков и кромок во время моделирования процесса ледообразования, а также приводит к затягиванию узких впадин и изломов (рис.~\ref{fig:text_1_remesh3_with_fensap}).
Свойство сглаживания мелких дефектов является крайне важным, так как обеспечивает устойчивость моделирования нарастания льда и позволяет отложить корректировку расчетной сетки вплоть до фазы устранения глобального дефекта -- самопересечения сетки.

\begin{figure}[!ht]
\centering
\begin{tabular}{ll}
\includegraphics[width=0.43\textwidth]{pics/text_1_remesh_3d/fens1.png}
&
\includegraphics[width=0.43\textwidth]{pics/text_1_remesh_3d/crys1.png} \\
\includegraphics[width=0.43\textwidth]{pics/text_1_remesh_3d/fens2.png}
&
\includegraphics[width=0.43\textwidth]{pics/text_1_remesh_3d/crys2.png}
\end{tabular}
\singlespacing
\caption{Эффект сглаживания дефектов при перестроении методом окрестностей (справа) в сравнении с программным комплексом FENSAP-ICE.}
\label{fig:text_1_remesh3_with_fensap}
\end{figure}

%---------------------------------------------------------------------------------------------------

\newpage
\textbf{Третья глава} посвящена вопросам пересечения поверхностной расчетной сетки с другими расчетными сетками.
Эти задачи возникают при поиске и удалении самопересечений поверхностной сетки, а также при сопряжении решателя на поверхностной расчетной сетки с газодинамическими решателями, работающими в окружающем поверхность пространстве.

В п.~3.1 рассматривается проблема устранения самопересечений поверхностной неструктурированной расчетной сетки.
Самопересечение является критическим дефектом сетки, при котором невозможно производить дальнейшие вычисления по моделированию ледообразования, поэтому самопересечения необходимо удалять.
В общем случае предотвратить возникновение самопересечений невозможно, так как в процессе ледообразования при активном нарастании льда возможно пересечение одних ледяных наростов с другими ледяными наростами.
Таким образом, для адекватного моделирования процесса ледообразования необходимо уметь корректно обрабатывать самопересечения расчетной сетки, чтобы после возникновения самопересечения можно быть продолжать выполнение расчетов.

\begin{figure}[!ht]
\centering
\includegraphics[width=1.0\textwidth]{./pics/text_1_int/bunnies_dbl.png}
\singlespacing
\caption{Поиск пар пересекающихся ячеек.}
\label{fig:text_1_int_1}
\end{figure}

Предлагаются два подхода к устранению самопересечений.
Первый подход основан на разбиении ячеек на более мелкие по множествам точек пересечения с другими ячейками.
Сначала требуется найти все пары пересекающихся ячеек сетки (рис.~\ref{fig:text_1_int_1}).
Для этого используется \textit{дерево облаков треугольников} -- иерархическая структура, позволяющая избежать проверки на пересечение каждой пары ячеек.
Основной проблемой при поиске множества точек пересечения двух треугольников являются ошибки точности, из-за которых может быть принято ошибочное решение о пересечении или непересечении: попадание узла на ребро или на ячейку, пересечение двух ребер, наложение ячеек или пересечение ячеек под острым углом.
В некоторых случаях такие конфликты можно разрешить локальной коррекцией положения узлов, тогда множество точек пересечения любой пары треугольников либо пусто, либо является отрезком.
Если конфликты удается разрешить, и пары пересекающися ячеек определены корректно, то все пересекающиеся ячейки сетки разбиваются на более мелкие ячейки по ломаным пересечения.
После дробления ячеек в сетке отсутствуют пересекающиеся ячейки, однако сетка перестает быть двусторонней, так как некоторые ребра в  ней имеют по 4 инцидентные ячейки, из которых две относятся к внешней поверхности, а две другие -- к скрытой области сетки, которая должна быть удалена.
Внешняя область сетки определяется путем обхода ячеек.
При переходе с некоторой ячейки $APQ$ через ребро $PQ$ с четырьмя инцидентными ячейками необходимо выбрать одну из трех ячеек $BPQ$, $CPQ$, $DPQ$.
В качестве следующей ячейки, которая войдет в результирующую внешнюю поверхность, выбирается ячейка $NPQ$, $N \in \{ B, C, D \}$, для которой значение функции $f(N) = (\overline{n}_{NPQ}^F, \overline{ON})$ максимально, где $O$ -- основание высоты треугольника $NPQ$, опущенной из вершины $N$ (рис.~\ref{fig:int_walk}).

\begin{figure}[!ht]
\centering
\includegraphics[width=0.75\textwidth]{./fig/int_walk.pdf}
\singlespacing
\caption{Обход внешней поверхности при устранении самопересечений.}
\label{fig:int_walk}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=1.0\textwidth]{./pics/text_1_int/wing_all.png}
\singlespacing
\caption{Устранение самопересечения с использованием подложки поверхностной сетки.}
\label{fig:text_1_int_2}
\end{figure}

При перестроении поверхности для задачи ледообразования расчетная сетка, как правило, отличается низким качеством -- в ней могут присутствовать ячейки с углами, близкими к $0$ или $\pi$, что препятствует корректному определению точек пересечения.
В этом случае используется второй подход к устранению самопересечений.
В пространстве строится восьмеричное дерево вложенных кубов, называемое \textit{подложкой}, где корень охватывает всю поверхность, а дочерние кубы строятся только в случае пересечения с сеткой.
Минимальный размер ячейки подложки выбирается меньше минимального ребра поверхностной сетки.
Далее определяется внешний слой кроны подложки, и все ячейки, не пересекающие этот слой, помечаются как кандидаты на удаление из сетки.
Также помечаются все ячейки, пересекающие другие ячейки в сетке.
После чего выполняется шаг стягивания сетки по ребрам, входящим в помеченную область.
После этого процесс повторяется итерационно, пока расчетная сетка не будет избавлена от самопересечений.
Такой подход не гарантирует устранение самопересечений на произвольной сетке, однако в отдельных случаях он оказывается применимым (например для расчетов на псевдотрехмерных профилях, рис.~\ref{fig:text_1_int_2}).

%----------------------------------

В п.~3.2 рассматривается проблема сопряжения поверхностной сетки с объемной сеткой и поиска их пересечений для определения поля скоростей вокруг обтекаемого тела.
При расчете обледенения крайне важным элементом данных является поле скоростей в области, окружающей рассматриваемую поверхность.
Поле скоростей вблизи поверхности влияет на движение жидкой пленки по поверхности, что существенным образом определяет картину обледенения.
Также при использовании модели вторичного увлажнения отскочившие от поверхности капли попадают в свободный поток, и поле скоростей необходимо для расчета траектории их движения и зоны вторичного выпадения.
Так как при перестроении поверхностной сетки построение согласованной объемной сетки является затратной процедурой, то для возможности продолжения расчетов предлагается метод погруженной границы с фиктивными ячейками.

Для реализации метода погруженной границы также используется подложка поверхностной расчетной сетки, и в этом разделе более детально рассматривается вопрос поиска пересечений поверхностной сетки с подложкой.
Для поиска пересечений поверхностной сетки с подложкой используется представление треугольной ячейки $ABC$ с помощью геометрического места точек (ГМТ) $\overline{P}(\beta, \gamma) = \overline{A} + \beta (\overline{B} - \overline{A}) + \gamma (\overline{C} - \overline{A}), \beta \ge 0, \gamma \ge 0, \beta + \gamma \le 1$ и ячейки в форме прямоугольного параллелепипеда в виде ГМТ $x_l \le x_P \le x_h, y_l \le y_P \le y_h, z_l \le z_P \le z_h$ и поиска точек, входящий в оба ГМТ методом свертывания системы линейных неравенств.

%----------------------------------

В п.~3.3 рассматривается \textit{метод погруженной границы} с использованием фиктивных ячеек в трехмерной постановке.
В предлагаемом методе строится декартова объемная сетка, в которой ячейки в виде прямоугольных параллелепипедов предварительно разделяются на четыре категории:
COMMON, \textit{внешние ячейки} -- целиком лежащие вне тела (к ним привязаны газодинамические величины, и в них выполняются вычисления), INNER, \textit{внутренние ячейки} -- целиком лежащие внутри тела (к ним не привязаны газодинамические величины, и в них не выполняются вычисления), BORDER, \textit{граничные ячейки} -- все остальные ячейки.
Далее из граничных ячеек выделяются те, для которых меньшая часть объема находится вне тела, а большая -- внутри тела.
Такие ячейки называются \textit{фиктивными}, к ним привязаны газодинамические величины, но они используются только для вычислений, проводимых с соседними COMMON ячейками, (GHOST) (рис.~\ref{fig:text_1_immersed_boundary_method_class} слева).

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_1_immersed_boundary_method/cells_classification.pdf}
\singlespacing
\caption{Классификация ячеек.}
\label{fig:text_1_immersed_boundary_method_class}
\end{figure}

После этого необходимо выполнить корректировку классификации ячеек для достижения выполнения следующего требования: соседями внутренних ячеек не могут являться ни граничные, ни внешние ячейки.
При этом некоторые INNER ячейки переходят в класс GHOST, а все оставшиеся BORDER ячейки -- в класс COMMON.
После корректировка классификации ячеек на границе COMMON области образуется слой GHOST ячеек. (рис.~\ref{fig:text_1_immersed_boundary_method_class} справа).
На каждой итерации расчетов для GHOST ячеек требуется выполнить аппроксимацию газодинамических величин (плотность, давление, вектор скорости), чтобы эти фиктивные ячейки могли быть использованы для определения потоков между ними и соседними с ними COMMON ячейками.
Аппроксимация скалярных и векторных газодинамических величин в GHOST ячейкаx выполняется с помощью шаблонов, в которые входят три COMMON ячейки, а также точка поверхности, в которой известно направление нормали $\overline{e}_0$.
Наиболее сложной процедурой является определение компонент скорости в фиктивной ячейке $\overline{v}_G$.

%===================================================================================================

\newpage
\textbf{Четвертая глава} посвящена задаче разработки методов повышения эффективности распараллеливания вычислений на поверхностных и объемных расчетных сетках.

%----------------------------------

В разделе~4.1 приводятся показатели распараллеливания в модели с передачей сообщений: \textit{ускорение} $s_{msg}(k) = T_1/T_k$ ($T_i$ -- время выполнения задачи на $i$ процессах), \textit{эффективность} $e_{msg}(k) = s_{msg}(k)/k$.
Для распараллеливания вычислений область задачи нужно разбить на подобласти (совокупности расчетных ячеек, \textit{домены}), распределить домены между процессами и организовать обмен сообщениями между доменами.
Эта задача эквивалентна задаче декомпозиции \textit{дуального графа} расчетной сетки $G = (V, E)$ (вершины графа соответствуют ячейкам сетки, ребро графа связывает две вершины, соответствующие соседним ячейкам), для которой рассматриваются показатели качества декомпозиции.
\textit{Неравномерность декомпозиции} $D = \max_{1 \le i \le k}{ \left( n_i - \frac{n}{k} \right) }$, $D^{*} = \frac{D}{n/k}$ ($n = |V|$, $n_i$ -- количество вершин в $i$-ом домене) характеризует простаивание вычислительных ресурсов во время обработки наибольшего домена.
\textit{Наибольшая длина границы между парой доменов} $L_{ij} = \left| \{ e \in E: \{ d(e_a), d(e_b) \} = \{ i, j \} \} \right|$, $L = \max_{1 \le i < j \le k}{L_{ij}}$ ($e_a$, $e_b$ -- инцидентные ребру $e$ вершины, $d(v)$ -- домен вершины $v$) определяет длительность информационных обменов между доменами.
\textit{Суммарная длина границ между доменами} $I = \sum_{1 \le i < j \le k}{L_{ij}}$ определяет общий объем данных при обмене сообщениями.

%----------------------------------

В разделе~4.2 рассматривается распределение вычислительной нагрузки между процессами при проведении вычислений на блочно-структурированной расчетной сетке.
Описывается архитектура блочно-структурированной расчетной сетки с поддержкой дробления блоков.
На распределение ячеек по доменам накладывается ограничение -- все ячейки одного и того же блока должны относиться к одному и тому же домену.
Негативное влияение этого ограничения на показатель $D$ может быть сглажено путем дробления блоков.

Рассматривается задача распределения $m$ блоков расчетной сетки между $k$ доменами в следующем виде.
Пусть $X$ -- множество чисел $x_i > 0$, $i \in M$, $M = [1, m]$.
Разбиение множества $X$ на множества $K = [1, k]$ -- это отображение $\gamma: M \rightarrow K$.
Веса результирующих множеств равны $X_j = \sum_{i \in M, \ \gamma(i) = j}{x_i}$.
Требуется найти разбиение, минимизирующее $X^{max} = \max_{j \in K}{X_j}$.

Точное решение поставленной задачи может быть найдено с помощью метода ветвей и границ, однако алгоритм поиска точного решения имеет экспоненциальную сложность и неприменим для больших $m$ и $k$.
Рассматривается жадный алгоритм поиска приближенного значения, в котором последовательно обрабатываются все веса, начиная с наибольшего.
Каждый необработанный вес добавляется к наиболее легкому на текущий момент множеству.

\textbf{Лемма}. \textit{Для жадного алгоритма распределения весов $X$ между множествами $K$ верна оценка $X^{max} - X^{avg} \le \max_{i \in M}{r_i}$, где $X^{avg} = \frac{1}{k}\sum_{j \in K}{X_j}$, $r_i = \max{( x_i - \frac{1}{k} \sum_{p = i}^{m}{x_p}, 0)}$.}

Характеристика $X^{max} - X^{avg}$ соответствует показателю $D$.
Из леммы можно сделать вывод о деградации показателя $D$ при наличии крупных блоков.
Для снижения значения $D$ предлагаются алгоритмы дробления блоков.
В первом алгоритме выполняется дробление наибольшего блока пополам до тех пор, пока не будет достигнуто требуемое значение $D$.
Также для уменьшения показателя $L$ предлагается эвристический алгоритм уменьшения количества дроблений, основанный на выборе разрезов блоков для наиболее близкого приближения веса домена к величине $X^{avg}$.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.95\textwidth]{./fig/par_distr_with_cut.pdf}
\singlespacing
\caption{Распределение блоков по доменам с дроблением.}
\label{fig:par_distr_with_cut}
\end{figure}

Из результатов сравнения предложенных алгоритмов (рис.~\ref{fig:par_distr_with_cut}) можно сделать вывод, что с помощью уменьшения количества дроблений можно добиться распределения не худшего качества (а зачастую и лучшего), чем при дроблении наибольшего блока,
при этом существенно сокращается количество дроблений.
Последовательность дроблений блоков сетки для достижения заданного значения показателя $D^{*}$ при распределении между $k$ доменами называется \textit{подготовкой сетки}.
Для демонстрации важности сокращения количества дроблений блоков приводятся результаты эксперимента по выполнению расчетов на блочно-структурированной расчетной сетке, с подготовкой для разных значений $k$ и $D^{*}$ при помощи дробления наибольшего блока.

\begin{figure}[ht]
\centering
\includegraphics[width=1.0\textwidth]{./fig/par_scaling_with_prepare.png}
\singlespacing
\caption{Масштабирование вычислений с подготовкой сетки.}
\label{fig:par_scaling_with_prepare}
\end{figure}

На рис.~\ref{fig:par_scaling_with_prepare} представлены результаты численных экспериментов масштабирования вычислений на блочно-структурированной расчетной сетке на 1-32 процессах.
На неподготовленной сетке ("нет дроблений") и при подготовке для $k = 16$ наблюдается ограничение ускорения, обусловленное наличием крупных блоков. 
При подготовке сетки для $k = 32$ и $k = 64$ с допустимым отклонением $D^{*} = 0{,}1$ наблюдается примерно одинаковое ускорение и эффективность распараллеливания с ростом количества процессов.
Это говорит о том, что подготовка сетки для большего количества процессов, чем реально будет использоваться для запусков, избыточно.
При подготовке сетки для $k = 64$ и $D^{*} = 0{,}01$ наблюдается деградация эффективности распараллеливания из-за возрастания количества дроблений, что приводит к увеличению объема межпроцессных обменов.

%----------------------------------

В разделе~4.3 рассматривается декомпозиция поверхностной неструктурированной расчетной сетки и предлагается алгоритм сглаживания границ между доменами.
Отмечены два используемых метода декомпозиции, отличающиеся показателями $D$ и $L$.
Метод декомпозиции с помощью \textit{наращивания доменов} с использованием генетического алгоритма для корректировки положения инициирующих вершин порождает неравномерное распределение вершин по доменам с достаточно гладкими границами.
Метод \textit{иерархического деления пополам} по наиболее протяженному геометрическому направлению наоборот порождает равномерное распределение вершин по доменам с протяженными <<пилообразными>> границами (рис.~\ref{fig:par_smooth_borders} а).

Алгоритм сглаживания границы между доменами рассматривается на неструктурированной поверхностной расчетной сетке, применяется к паре доменов и направлен на уменьшение длины границы между ними с сохранением баланса количества ячеек в этих доменах.
Алгоритм рассматривается для границы в виде простой цепи ребер сетки.
Сначала в цепи ищутся все пригодные для сглаживания границы \textit{шаблоны} -- локальные преобразования, уменьшающие длину границы (рис.~\ref{fig:par_smooth_borders} б).
После нахожения потенциально пригодных шаблонов выполняется разметка влияния шаблонов друг на друга, шаблон может повлиять только на своих непосредственных соседей.
Последним шагом алгоритма является выбор подмножества независимых шаблонов, которые могут быть применены одновременно и не нарушают суммарного баланса ячеек между доменами.
Ввиду того, что применение каждого шаблона уменьшает длину границы на 1, задача поиска оптимального решения может быть сформулирована в виде поиска в множестве шаблонов подмножества максимального размера, не содержащего конфликтующих шаблонов.
Задачу можно сформулировать в терминах динамического программирования.
Для этого рассматривается функция $B(t, u, x)$, отражающая изменение длины границы при решении задачи на множестве шаблонов $\{ t' \in T : t' \ge t \}$ при условии изменения баланса ячеек на $u$ единиц.
Параметр $x$ является булевым и принимает значение $1$, если шаблон $t$ вошел в решение, и $0$ -- в противном случае.
Решением поставленной задачи является значение $\min_{x \in \{0, 1\}}{B(t_0, 0, x)}$, где $t_0$ -- первый шаблон на рассматриваемой цепи.

\begin{figure}[ht]
\centering
\begin{tabular}{ll}
\begin{subfigure}{0.5\textwidth}\centering\includegraphics[width=0.75\columnwidth]{./pics/text_2_smooth/bad-border.pdf}\caption{<<пилообразные>> границы}\end{subfigure} &
\begin{subfigure}{0.5\textwidth}\centering\includegraphics[width=0.75\columnwidth]{./pics/text_2_smooth/smooth-border.pdf}\caption{шаблоны сглаживания}\end{subfigure}
\end{tabular}
\singlespacing
\caption{Сглаживание границ между доменами.}
\label{fig:par_smooth_borders}
\end{figure}

\textbf{Лемма.} \textit{Задача о поиске в множестве шаблонов максимального подмножества без конфликтов может быть решена точно со сложностью алгоритма $O \left( |T| \cdot (U^{max} - U^{min} + 1) \right)$, $U^{min} = \frac{1}{2} \sum_{t \in T}{(U(t) - |U(t)|)}$ и $U^{max} = \frac{1}{2} \sum_{t \in T}{(U(t) + |U(t)|)}$ -- нижняя и верхняя границы баланса ячеек, $U(t)$ -- изменение баланса ячеек в домене при испольовании шаблона $t$.}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.8\textwidth]{./pics/text_2_smooth/decomp2.pdf}
\singlespacing
\caption{Эффект от сглаживания границ между доменами.}
\label{fig:text_2_smooth_decomp2}
\end{figure}

На рис.~\ref{fig:text_2_smooth_decomp2} продемонстрированы отдельные части тестовой расчетной сетки с отображением ребер ячеек.
На этом рисунке виден эффект от применения алгоритма сглаживания границ между доменами.
Применение алгоритма сглаживания границ приводит к сокращению длин границ между доменами примерно на 10\%.

\begin{figure}[!ht]
\centering
\includegraphics[width=1.0\textwidth]{pics/text_2_scaling/2in1.png}
\singlespacing
\caption{Масштабирование расчетов на суперкомпьютере МВС-10П.}
\label{fig:text_2_scaling_speedup_eff}
\end{figure}

В разделе описан эксперимент по замеру ускорения и эффективности распараллеливания задачи расчета ледообразования на поверхностной неструктурированной расчетной сетке с использованием метода иерархического деления доменов со сглаживанием границ между доменами (рис.~\ref{fig:text_2_scaling_speedup_eff}).

%----------------------------------

В разделе~4.4 рассматриваются вопросы распараллеливания вычислений на поверхностной неструктурированной сетке на общей памяти.

Рассматривается проблема устранения конфликтов по данным при распараллеливании конечно-объемных численных методов на поверхностной расчетной сетке.
Конфликты по данным возникают при параллельной обработке перетекания потоков между ячейками.
Рассматривается два подхода к устранению конфликтов.
В качестве первого подхода рассматривается использование директивы \texttt{\#pragma omp atomic} при доступе к элементам данных, по которым возможно возникновение конфликтов.
В качестве второго подхода рассматривается реберная раскраска дуального графа расчетной сетки, с помощью которой множество ребер разбивается на подмножества без конфликтов.
Приводятся алгоритмы реберной раскраски дуального графа поверхностной неструктурированной расчетной сетки в 5 и 4 цвета с линейной сложностью по количеству ребер, а также квадратичный алгоритм раскраски в 3 цвета, основанный на исследованиях раскрасок плоских графов\footnote[4]{С.В.~Курапов, М.В.~Давидовский, А.В.~Толок. Визуальный алгоритм раскраски плоских графов. // Научная визуализация, 2018, том~10, №~3, с.~1-33, doi:~10.26583/sv.10.3.01}.
Численные эксперименты показали, что метод устранения конфликтов с помощью реберной раскраски дуального графа приводит к существенному ускорению расчетов на большом количестве потоков.

Рассматривается сравнение эффективности распараллеливания скалярных и векторных вычислений (газодинамический решатель) на общей памяти для вычислительных узлов на базы микропроцессоров Intel (Phi KNL, Skylake, Cascade Lake).

\begin{figure}[ht]
\centering
\includegraphics[width=1.0\textwidth]{./fig/par_openmp_scalar_vec_chart.png}
\singlespacing
\caption{Графики ускорения и эффективности распараллеливания скалярных и векторизованных вычислений.}
\label{fig:text_3_omp2}
\end{figure}

На рис.~\ref{fig:text_3_omp2} слева представлены графики ускорения скалярной и векторной версии газодинамического решателя на 1-160 потоках.
Для каждого вычислительного узла явно просматриваются отрезки квазилинейного ускорения, которые завершаются провалами.
Длина этих отрезков совпадает с количеством ядер в узле, а провалы обусловлены конкуренцией за аппаратные ресурсы.
Для всех узлов ускорение близко к линейному до тех пор, пока каждый поток запущен на своем ядре.
Из графиков эффективности распараллеливания видно, что эффективность распараллеливания векторных версий кода примерно вдвое ниже эффективности распараллеливания скалярных версий.
Это говорит о целесообразности векторизации программного кода при достижении ускорения от векторизации хотя бы в два раза.

%----------------------------------

Выводы...

%===================================================================================================

\newpage
\textbf{Пятая глава} посвящена вопросам \textit{векторизации вычислений}.
Векторизация является оптимизацией распараллеливания вычислений на уровне инструкций и способна кратно увеличить производительность приложений.
Набор векторных инструкций AVX-512 обладает рядом особенностей и позволяет векторизовать сложный программный контекст с обилием операций передачи управления, гнездами циклов и вызовами функций.
Для оценки эффективности векторизации используются понятия \textit{ширина векторизации} $w = v/t$ ($v$ -- размер векторного регистра, $t$ -- размер типа расчетных данных), \textit{ускорение} $s_{vec} = T/T_v$ ($T$ -- время выполнения скалярной версии кода, $T_v$ -- время выполнения векторизованной версии кода), \textit{эффективность} $e_{vec} = s_{vec}/w$, а также \textit{логическое ускорение} $s_{vec}^{*} = L/L_v$ ($L$ -- количество выполненных инструкций в скалярном коде, $L_v$ -- количество выполненных аналогичных им векторных инструкций в векторном коде), \textit{логическая эффективность} $e_{vec}^{*} = s_{vec}^{*}/w$.

%----------------------------------

В разделе~5.1 приведено описание набора векторных инструкций AVX-512, перечислены основные подмножества операций и рассмотрены особенности этого набора.
Основной отличительной чертой этого набора инструкций, позволяющей векторизовать программный контекст со сложным управлением, является возможность выполнения векторных инструкций с использованием \textit{векторных масок}, определяющих индексы элементов, для которых в выходной регистр записывается результат операции.

%----------------------------------

В разделе~5.2 рассматривается векторизация программного кода путем выделения однотипных инструкций и объединения их в векторные аналоги на примере операций с матрицами малой размерности.
На примере матричных операций показано, что от способа выделения однотипных инструкций для объединения в векторные аналоги существенным образом зависит производительность результирующего кода.
Также продемонстрировано, что низкая \textit{плотность векторных масок} (доля единичных битов в маске) в результирующем коде негативно сказывается на производительности.

%----------------------------------

В разделе~5.3 вводится понятие \textit{плоского цикла} как удобного контекста для векторизации вычислений, что делает его предпочтительной формой компоновки программного кода для успешного автоматического применения векторизации оптимизирующим компилятором.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./fig/vec_block_BLOCK.pdf}
\singlespacing
\caption{Скалярный блок block и аналогичный ему векторный блок BLOCK.}
\label{fig:vec_block_BLOCK}
\end{figure}

Идея плоского цикла состоит в объединении $w$ нескольких экземпляров \textit{скалярного блока} в единый \textit{векторный блок}, состоящий из аналогичных векторных инструкций.
На рис.~\ref{fig:vec_block_BLOCK} $w$ экземпляров скалярного блока $block(x, y) \rightarrow r$ со скалярными входными данными $x$, $y$ и скалярным результатом $r$ объединены в векторный блок $BLOCK(X, Y) \rightarrow R$ с векторными входными данными $X$, $Y$ и векторным результатом $R$.
В качестве плоского рассматривается цикл \texttt{for (int i = 0; i < w; ++i)}, к которому предъявляются следующие требования.
На $i$-ой итерации все обращения к данным на запись имеют вид \texttt{a[i]}, а обращения к данным на чтение либо имеют вид \texttt{a[i]}, либо являются чтением скаляров.
Все массивы данных, обращение к которым на $i$-ой итерации цикла имеет вид \texttt{a[i]}, выровнены в памяти на размер вектора.
В цикле отсутствуют межитерационные зависимости.
Без ограничения общности можно считать, что плоский цикл содержит произвольное количество итераций $n$, так как с помощью расщепления цикла по индуктивной переменной он может быть разбит на $\lfloor n/w \rfloor$ циклов с $w$ итерациями и возможно еще один с меньшим количеством итераций (\textit{эпилог}).
Цикл, в котором нарушаются некоторые другие из приведенных требований, называется \textit{квазиплоским}.

\begin{figure}[!ht]
\centering
\includegraphics[width=1.0\textwidth]{./fig/vec_avx512_semantic_table.pdf}
\singlespacing
\caption{Инструкции AVX-512 для работы с вещественными числами и их семантика. $A$, $B$, $R$ -- векторные регистры, $P$, $Q$ -- векторные маски.}
\label{fig:vec_avx512_semantic_table}
\end{figure}

Плоский цикл является удобным для векторизации программным контекстом и зачастую может быть заменем на векторный блок (или на несколько соседних векторных блоков в случае произвольного количества итераций $n > w$), а логика работы многих векторных инструкций может быть представлена в виде плоского цикла и записана в предикатной форме (рис.~\ref{fig:vec_avx512_semantic_table}).

Обсуждается применение автоматической векторизации к программному коду, представленному в виде композиции плоских циклов (на примере реализации газодинамического решателя), а также демонстрируется деградация производительности на квазиплоских циклах (рис.~\ref{fig:vec_diagram_ibm_functions}).
Для приведения программного кода к виду плоских циклов применяется организация данных в виде набора массивов, а также расщепление циклов по константному условию для сокращения количества операций передачи управления внутри цикла.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.7\textwidth]{./fig/vec_diagram_ibm_functions.pdf}
\singlespacing
\caption{Диаграмма $s_{vec}$ и $e_{vec}$ функций газодинамического решателя.}
\label{fig:vec_diagram_ibm_functions}
\end{figure}

%----------------------------------

В разделе~5.4 рассматривается оптимизация \textit{выноса маловероятного региона из плоского цикла}.
Инструкции передачи управления не имеют векторных аналогов, их наличие в коде является основной причиной низкой эффективности векторизации.
Большинство ориентированных на векторизацию оптимизаций направлены на упрощение управления в векторизуемом коде. 
Оптимизация выноса маловероятного региона заключается в сохранении условий входа в этот регион во временный массив и удалении его из основного цикла.
Основной цикл, свободный от удаленного региона, может быть успешно векторизован, а вынесенный маловероятный регион может быть обработан в отдельном цикле согласно сохраненным условиям.

%----------------------------------

В разделе~5.5 рассматривается оптимизация \textit{слияния путей исполнения по условию} внутри плоского цикла с помощью постановки операций из параллельных скалярных блоков под предикаты этих блоков, трансформирующиеся при векторизации в векторные маски.
Приводятся аналитические оценки логической эффективности векторизации плоского цикла, в котором два скалярных блока (с вероятностями $p$ и $1 - p$ и длинами $\frac{\alpha}{\alpha + 1}$ и $\frac{1}{\alpha + 1}$ соответственно) сливаются по условию в случае независимости условий с разных итераций плоского цикла.
Рассматриваются два варианта векторного кода -- без проверки маски векторного блока на пустоту перед его выполнением и с проверкой (рис.~\ref{fig:vec_ifconv_nocheck_check}).
Из приведенных на рис.~\ref{fig:vec_charts_nocheck_check} графиков зависимостей логической эффективности векторизации от вероятности перехода $p$ можно сделать вывод о низкой эффективности векторизации при слиянии большого количества путей исполнения внутри плоского цикла.

\begin{figure}[ht]
\centering
\begin{tabular}{ll}
\begin{subfigure}{0.5\textwidth}\centering\includegraphics[width=0.85\columnwidth]{./fig/vec_ifconv_nocheck.pdf}\caption{простое слияние}\end{subfigure} &
\begin{subfigure}{0.5\textwidth}\centering\includegraphics[width=0.85\columnwidth]{./fig/vec_ifconv_check.pdf}\caption{слияние с проверкой масок}\end{subfigure}
\end{tabular}
\singlespacing
\caption{Схема векторизации со слиянием блоков.}
\label{fig:vec_ifconv_nocheck_check}
\end{figure}

\begin{figure}[ht]
\centering
\begin{tabular}{ll}
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=0.85\columnwidth]{./pics/text_4_vec_mrg_under_cond/chart_e_merged.png}\caption{простое слияние}\end{subfigure} &
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=0.85\columnwidth]{./pics/text_4_vec_check_mask/chart_e_merged.png}\caption{слияние с проверкой масок}\end{subfigure}
\end{tabular}
\singlespacing
\caption{Графики зависимости $e_{vec}^{*}$ от вероятности перехода $p$ при разных $\alpha$.}
\label{fig:vec_charts_nocheck_check}
\end{figure}

\begin{figure}[ht]
\centering
\begin{tabular}{ll}
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=0.85\columnwidth]{./pics/text_4_vec_comb_mask/independent_p.png}\caption{независимые условия}\end{subfigure} &
\begin{subfigure}{0.45\textwidth}\centering\includegraphics[width=0.85\columnwidth]{./pics/text_4_vec_comb_mask/real_p.png}\caption{реальное приложение}\end{subfigure}
\end{tabular}
\singlespacing
\caption{Типовое распределение количества единичных битов в маске.}
\label{fig:vec_masks_density}
\end{figure}

Отмечается, что проверка векторной маски на пустоту перед выполнением векторного блока зачастую оправдана, так как на реальных приложениях пустые маски встречаются достаточно часто (рис.~\ref{fig:vec_masks_density}).
Это связано с тем, что на расчетных приложениях характерно медленное изменение величин при переходе между итерациями плоского цикла, что влечет за собой медленное изменение условий, что в свою очередь приводит к частому возникновению пустых и полных масок при векторизации.

%----------------------------------

В разделе~5.6 рассматривается повышение плотности масок векторного кода с помощью \textit{объединения масок} и \textit{комбинирования масок} соседних векторных блоков.
Так как в общем случае без учета комбинированных операций $L = w \sum_{c \in C_v}{\rho(m(c))}$ ($C_v$ -- множество векторных инструкций в векторном коде, $m(c)$ -- маска инструкции, $\rho(m)$ -- плотность маски), то для повышения эффективности векторизации требуется повышение плостности векторных масок.
Если два соседних векторных блока \texttt{block(in\_data\_1)} $\rightarrow$ \texttt{out\_data\_1} и \texttt{block(in\_data\_2)} $\rightarrow$ \texttt{out\_data\_2} выполняются под непересекающимися масками \texttt{(mask\_1 \& mask\_2) == 0x0}, то вычисления в этих блоках можно объединить.
Вместо их последовательного выполнения можно объединить входные данные \texttt{in\_data\_1} и \texttt{in\_data\_2} с помощью слияния \texttt{in\_data = blend(mask\_1, in\_data\_2, in\_data\_1}), после чего выполнить тот же блок вычислений под маской \texttt{mask\_1 | mask\_2}.
Ввиду отсутствия пересечения векторных масок в результирующих выходных данных \texttt{out\_data} будут содержаться как необходимые элементы данных \texttt{out\_data\_1}, так и необходимые элементы данных \texttt{out\_data\_2} (рис.~\ref{fig:vec_unite_masks}).
Комбинирование масок позволяет объединить вычисления в соседних блоках в случае пересечения векторных масок, если сумма их плотностей не превышает единицу.

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{./fig/vec_unite_masks.pdf}
\singlespacing
\caption{Схема вычислений с объединением масок двух векторных блоков.}
\label{fig:vec_unite_masks}
\end{figure}

%----------------------------------

В разделе~5.7 проводится анализ программного контекста, в котором тело плоского цикла само содержит циклы или гнезда циклов.
На рис.~\ref{fig:vec_flat_loop_nest} представлена схема векторизации плоского цикла, в теле которого содержится внутренний цикл (\textit{структура <<плоский цикл / внутренний цикл>>}).

\begin{figure}[!ht]
\centering
\includegraphics[width=0.7\textwidth]{./fig/vec_flat_loop_nest.pdf}
\singlespacing
\caption{Схема векторизации стуктуры <<плоский цикл / вложенный цикл>>.}
\label{fig:vec_flat_loop_nest}
\end{figure}

При выполнении векторизации тело внутреннего цикла $block$, выполняемое по условию $cond$, переводится в векторный блок $BLOCK$, инструкции которого выполняются под маской $COND$, которая постепенно истощается пока не станет равной \texttt{0x0}.
При этом выполняется соотношение $I_v = \max_{i = 0}^{w - 1}{I(i)}$, где $I(i)$ -- количество итераций внутреннего цикла на $i$-ой итерации плоского цикла, $I_v$ -- количество итераций внутреннего цикла в векторизованной версии.
Эффективность векторизации рассматриваемого программного кода зависит от характера измерения условия $cond$ (и соответственно функции $I(i)$) при переходе между итерациями плоского цикла.
В терминах количества итераций может формулируется следующая лемма.

\textbf{Лемма.} \textit{При векторизации структуры <<плоский цикл / внутренний цикл>> верна априорная оценка $e_{vec}^{*} \le e_{vec}^I$, где $e_{vec}^I = ( \sum_{i = 0}^{w - 1}{I(i)} ) / (I_v w)$.
При этом, если выполняется соотношение $I_v - \min_{i = 0}^{w - 1}{I(i)} \le \epsilon$, то $e_{vec}^I \ge 1 - \frac{\epsilon}{I_v}$. Коэффициент $\epsilon$ называется коэффициентом регулярности количества итераций внутреннего цикла.}

Отдельно рассматриваются различные виды внутреннего цикла, и анализируется влияние его характера на эффективность векторизации.

В разделе~5.7.1 рассматривается внутренний \textit{цикл с фиксированным количеством итераций}, то есть условие выхода из которого является константным для векторизуемого плоского цикла.
В этом случае $e_{vec}^I = 1$, при векторизации условие выхода из внутреннего цикла переносится в векторизованный код в неизменном виде.

В разделе~5.7.2 рассматривается внутренний \textit{цикл с непостоянным количеством итераций}, то есть в котором условие выхода из цикла зависит от номера итерации векторизуемого плоского цикла, но изменяется медленно (значение коэффициента $\epsilon$ мало).
При векторизации условие выхода из внутреннего цикла трансформируется в векторную маску выполнения тела, и внутренний цикл продолжает исполняться до тех пор, пока эта векторная маска не истощится.
Основной причиной потери производительности при векторизации такого программного контекста является выполнение итераций внутреннего цикла под маской низкой плотности.

В разделах~5.7.3 и 5.7.4 рассматривается вещественный и целочисленный программный контекст в котором внутренний цикл характеризуется как \textit{цикл с нерегулярным количеством итераций} (значение коэффициента $\epsilon$ сравнимо с величиной $I_v$).
При векторизации такого программного контекста плотность маски выполнения внутреннего цикла является крайне низкой, что приводит к наиболее серьезной потери производительности. 

%----------------------------------

\begin{figure}[!ht]
\centering
\includegraphics[width=1.0\textwidth]{./fig/vec_fin_map.pdf}
\singlespacing
\caption{Карта эффективности векторизации.}
\label{fig:vec_fin_map}
\end{figure}

В выводах из главы приводится общая карта рассмотренного в главе векторизованного программного контекста, представленная на рис.~\ref{fig:vec_fin_map}.
Из карты делается вывод, что наиболее неудобным программным контекстом для векторизации являются гнезда циклов с нерегулярным количеством итераций, а также квазиплоские циклы c дополнительной косвенностью при обращении в память, невыровненностью данных и другими нарушениями требований, предъявляемых к плоским циклам.
Наиболее удобным контекстом для векторизации являются плоские циклы с простым управлением и применением проверок и объединения масок.
Рассмотренные в главе преобразования, направленные на упрощение управления в плоском цикле и повышение плотности масок в векторном коде приводят к повышению эффективности векторизации и могут быть использованы для ускорения высокопроизводительных приложений. 

%---------------------------------------------------------------------------------------------------

x

x

x

x

x

x

x

x

x

\newpage
\section*{Список основных публикаций автора по теме работы}

\begin{enumerate}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
\item Рыбаков~А.~А. Декомпозиция расчетной сетки с помощью генетического алгоритма. // Программные продукты и системы, 2025, Т.~38, №~2, С.~337-344.
\item Рыбаков~А.~А. Векторизация циклов с условными операциями с помощью комбинирования векторных масок. // Современные информационные технологии и ИТ-образование, 2024, Т.~20, №~3, С.~520-534.
\item Гуличева~А.~А., Рыбаков~А.~А. Реберная раскраска кубического графа в задаче распараллелирования расчетов на неструктурированной поверхностной расчетной сетке. // Программные продукты и системы, 2024, Т.~37, №~3, С.~374-383.
\item Рыбаков~А.~А., Швиндт~А.~Н. Создание инструментария для векторизации тела плоского цикла с помощью векторных инструкций AVX-512. // Программные продукты и системы, 2023, Т.~36, №~4, С.~561-572.
\item Рыбаков~А.~А. Геометрическое перестроение расчетной сетки с помощью общей огибающей семейства сфер в задаче ледообразования. // Современные информационные технологии и ИТ-образование, 2023, Т.~19, №~2, С.~282-291.
\item Рыбаков~А.~А., Мещеряков~А.~О. Векторизация трехмерного метода погруженных границ для повышения эффективности расчетов на микропроцессорах Intel. // Программные продукты и системы, 2023, Т.~36, №~1, С.~130-143.
\item Meshcheryakov~A.~O., Rybakov~A.~A. Evolution of the surface computational mesh in the ice accretion process. // Lobachevskii Journal of Mathematics, 2023, Vol.~44, No.~11, P.~361-378.
\item Freylekhman~S.~A., Rybakov~A.~A. Self-intersection elimination for unstruc-tured surface computational meshes. // Lobachevskii Journal of Mathema-tics, 2022, Vol.~43, No.~10, P.~2846-2852.
\item Рыбаков~А.~А. Векторизация программного кода, содержащего маловероятные регионы, в задачах вычислительной геометрии. // Современные информационные технологии и ИТ-образование, 2022, Т.~18, №~1, С.~28-38.
\item Багров~А.~Д., Рыбаков~А.~А. Сглаживание границ между доменами поверхностной расчетной сетки. // Современные информационные технологии и ИТ-образование, 2021, Т.~17, №~2, C.~265-274.
\item Shabanov~B.~M., Rybakov~A.~A., Shumilin~S.~S., Vorobyov~M.~Yu. Scaling of supercomputer calculations on unstructered surface computational meshes. // Lobachevskii Journal of Mathematics, 2021, Vol.~42, No.~11, P.~2571-2579.
\item Рыбаков~А.~А., Чопорняк~А.~Д. Декомпозиция поверхностной неструктурированной расчетной сетки для масштабирования вычислений на суперкомпьютере. // Современные информационные технологии и ИТ-образование, 2020, Т.~16, №~4, С.~851-861.
\item Рыбаков~А.~А. Метод погруженной границы с использованием фиктивных ячеек в трехмерной постановке. // Современные информационные технологии и ИТ-образование, 2020, Т.~16, №~2, С.~321-330.
\item Savin~G.~I., Shabanov~B.~M., Rybakov~A.~A., Shumilin~S.~S. Vectorization of flat loops of arbitrary structure using instructions AVX-512. // Lobachevskii Journal of Mathematics, 2020, Vol.~41, No.~12, P.~2566-2574.
\item Рыбаков~А.~А., Шумилин~С.~С. Исследование эффективности векторизации гнезд циклов с нерегулярным числом итераций. // Программные системы: Теория и приложения, 2019, Т.~10, №~4(43), С.~77-96.
\item Рыбаков~А.~А., Шумилин~С.~С. Векторизация римановского решателя с использованием набора инструкций AVX-512. // Программные системы: Теория и приложения, 2019, Т.~10, №~3(42), С.~59-80.
\item Rybakov~A.~A., Shumilin~S.~S. Approximate methods of the surface mesh deformation in two-dimensional cases. // Lobachevskii Journal of Mathema-tics, 2019, Vol.~40, No.~11, P.~1848-1852.
\item Savin~G.~I., Benderskiy~L.~A., Lyubimov~D.~A., Rybakov~A.~A. RANS/ILES method optimization for effective calculations on supercomputer. // Loba-chevskii Journal of Mathematics, 2019, Vol.~40, No.~5, P.~566-573.
\item Shabanov~B.~M., Rybakov~A.~A., Shumilin~S.~S. Vectorization of high-performance scientific calculations using AVX-512 instruction set. // Loba-chevskii Journal of Mathematics, 2019, Vol.~40, No.~5, P.~580-598.
\item Бендерский~Л.~А., Рыбаков~А.~А., Шумилин~С.~С. Векторизация перемножения малоразмерных матриц специального вида с использованием инструкций AVX-512. // Современные информационные технологии и ИТ-образование, 2018, Т.~14, №~3, С.~594-602.
\item Бендерский~Л.~А., Лещев~С.~А., Рыбаков~А.~А. Векторизация операций над матрицами малой размерности для процессора Intel Xeon Phi Knights Landing. // Современные информационные технологии и ИТ-образование, 2018, Т.~14, №~1, С.~73-90.
\item Рыбаков~А.~А. Оптимизация задачи об определении конфликтов с опасными зонами движения летательных аппаратов для выполнения на Intel Xeon Phi. // Программные продукты и системы, 2017, Т.~30, №~3, С.~524-528.
\item Рыбаков~А.~А. Внутреннее представление и механизм межпроцессного обмена для блочно-структурированной сетки при выполнении расчетов на суперкомпьютере. // Программные системы: теория и приложения, 2017, Т.~8, №~1(32), С.~121-134.
\item Рыбаков~А.~А. Распределение вычислительной нагрузки между узлами суперкомпьютерного кластера при расчетах задач газовой динамики с дроблением расчетной сетки. // Современные информационные технологии и ИТ-образование, 2016, Т.~12, №~2, С.~101-107.
\end{enumerate}

% Другие статьи (Труды НИИСИ, сборник конференции).
%\begin{enumerate}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
%\item Рыбаков~А.~А., Телегин~П.~Н., Шабанов~Б.~М. Проблемы векторизации гнезд циклов с использованием инструкций AVX-512. // Электронный научный журнал: Программные продукты, системы и алгоритмы, 2018, №~3, С.~1-11.
%\item Рыбаков~А.~А. Распределение вычислительной нагрузки между узлами гетерогенного вычислительного кластера. // Электронный научный журнал: Программные продукты, системы и алгоритмы, 2018, №~1, C.~26-32.
%\item Шабанов~Б.~М., Рыбаков~А.~А., Чопорняк~А.~Д. Оптимизации, применяемые к графу потока управления программы для повышения эффективности векторизации плоских циклов. // Труды НИИСИ РАН, 2021, Т.~11, №~2, С.~11-19.
%\item Воробьев~М.~Ю., Рыбаков~А.~А., Никсон Муганда Очара. Исследование масштабируемости плотных параллельных вычислений на микропроцессорах Intel. // Инжиниринг предприятий и управление знаниями (ИП\&УЗ-2020). Сборник научных трудов XXIII Международной научной конференции, 2020, С.~45-52.
%\item Воробьев~М.~Ю., Рыбаков~А.~А., Чопорняк~А.~Д. Сравнение стратегий распараллеливания векторизованного римановского решателя с помощью OpenMP для микропроцессора Intel Xeon Phi KNL. // Труды НИИСИ РАН, 2020, Т.~10, №~5-6, С.~113-119.
%\item Рыбаков~А.~А., Чопорняк~А.~Д. Повышение производительности векторного кода с помощью мониторинга плотности масок в векторных инструкциях. // Труды НИИСИ РАН, 2020, Т.~10, №~4, С.~40-47.
%\item Рыбаков~А.~А. Векторизация нахождения пересечения объемной и поверхностной сеток для микропроцессоров с поддержкой AVX-512. // Труды НИИСИ РАН, 2019, Т.~9, №~5, С.~5-14.
%\item Rybakov~A.~A., Shumilin~S.~S. Vectorization of the Riemann solver using the AVX-512 instruction set. // Program Systems: Theory and Applications, 2019, Vol.~10, №~3(42), P.~41-58.
%\item Рыбаков~А.~А., Шумилин~С.~С. Векторизация сильно разветвленного управления с помощью инструкций AVX-512. // Труды НИИСИ РАН, 2018, Т.~8, №~4, С.~114-126.
%\item Бендерский~Л.~А., Любимов~Д.~А., Рыбаков~А.~А. Инструментарий подготовки блочно-структурированной сетки для проведения расчетов методом RANS/ILES. // Труды НИИСИ РАН, 2018, Т.~8, №~4, С.~102-106.
%\item Бендерский~Л.~А., Любимов~Д.~А., Рыбаков~А.~А. Анализ эффективности масштабирования при расчетах высокоскоростных турбулентных течений на суперкомпьютере RANS/ILES методом высокого разрешения. // Труды НИИСИ РАН, 2017, Т.~7, №~4, С.~32-40.
%\end{enumerate}

\end{document}
