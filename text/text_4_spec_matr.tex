% Векторизация перемножения матриц специального вида.
\subsection{Векторизация перемножения малоразмерных матриц специального вида}

При проведении вычислений с помощью метода RANS/ILES расчетные параметры компонуются внутри матриц размером 5x5, при этом данные матрицы являются подматрицами матриц размера 8x8 (это делается из соображений выровненности расположения в памяти).
Наиболее частой операцией при проведении вычислений является перемножением таких матриц (данная функция занимает до 40\% расчетного времени).
Поэтому для повышения эффективности проведения расчетов с использованием метода RANS/ILES требуется эффективная реализация функций для работы с обозначенными объектами.

\begin{figure}[ht]
	\centering
		\includegraphics[width=1.00\textwidth]{./pics/text_4_spec_matr/matrices.pdf}
	\caption{Иллюстрация матриц размера 8x8, 7x7, 6x6, 5x5, представленных как подматрицы матрицы 8x8}
	\label{fig:text_4_spec_matr_matrices}
\end{figure}

В работе предыдущем разделе был рассмотрен подход к перемножению матриц размера 8x8 и 16x16 с элементами типа float, основной идеей которого было вначале выполнить операции поэлементного перемножения строк первой матрицы на столбцы второй матрицы, а затем параллельно вычислитель суммы элементов соответствующих векторов.
В случае матриц 16x16 параллельно вычислялась сумма элементов 16 векторов, в случае матриц 8x8 параллельно вычислялась сумма элементов половинок 8 векторов.
Достигалось это последовательным применением шаблонных связок, состоящих из операций perm, add и blend.

Данная реализация обладает существенными недостатками.
Во-первых, в коде присутствуют медленные инструкции gather/scatter, читающие из памяти элементы данных с произвольными смещениями, которые выполняются существенно медленнее чтения из памяти последовательных данных [25].
Во-вторых, выполнение сначала поэлементного перемножения векторов, а затем параллельное нахождение сумм их элементов (в данном случае рассчитываются суммы элементов половинок векторов), делают невозможным использование эффективных комбинированных инструкций fmadd.

\subsubsection{Теоретическая часть}

Запишем в явном виде значения элементов i-й строки результирующей матрицы:
\begin{equation}
	\left\{
		\begin{aligned}
			& r_{i0} = a_{i0}b_{00} + a_{i1}b_{10} + \cdots + a_{i7}b_{70} \\
			& \cdots \\
			& r_{i7} = a_{i0}b_{07} + a_{i1}b_{17} + \cdots + a_{i7}b_{77}
		\end{aligned}
	\right.
\end{equation}

или в векторном виде
\begin{equation}
	\overline{r}_i = a_{i0}\overline{b}_0 + a_{i1}\overline{b}_1 + \cdots + a_{i7}\overline{b}_7
\end{equation}

Аналогичные выражения можно записать для строки с номером $i + 1$:
\begin{equation}
	\left\{
		\begin{aligned}
			& r_{i + 1,0} = a_{i + 1,0}b_{00} + a_{i + 1,1}b_{10} + \cdots + a_{i + 1,7}b_{70} \\
			& \cdots \\
			& r_{i + 1,7} = a_{i + 1,0}b_{07} + a_{i + 1,1}b_{17} + \cdots + a_{i + 1,7}b_{77}
		\end{aligned}
	\right.
\end{equation}

или в векторном виде
\begin{equation}
	\overline{r}_{i + 1} = a_{i + 1,0}\overline{b}_0 + a_{i + 1,1}\overline{b}_1 + \cdots + a_{i + 1,7}\overline{b}_7
\end{equation}

Учитывая то, что zmm регистры содержат по 16 элементов типа float, то целесообразно объединить приведенные выше формулы в одну, записанную в векторном виде следующим образом:
\begin{equation}
	\begin{pmatrix}
		\overline{r}_i \\
		\overline{r}_{i + 1}
	\end{pmatrix}
	=
	\left(
		\begin{pmatrix}
			\overline{a}_{i0} \\
			\overline{a}_{i + 1,0}
		\end{pmatrix} \circ
		\begin{pmatrix}
			\overline{b}_0 \\
			\overline{b}_0
		\end{pmatrix}
	\right)
	+ \cdots +
	\left(
		\begin{pmatrix}
			\overline{a}_{i7} \\
			\overline{a}_{i + 1,7}
		\end{pmatrix} \circ
		\begin{pmatrix}
			\overline{b}_7 \\
			\overline{b}_7
		\end{pmatrix}
	\right)
\end{equation}

где $\begin{pmatrix}\overline{r}_i \\ \overline{r}_{i + 1}\end{pmatrix}$ обозначает обозначает комбинированный вектор состоящий из векторов $\overline{r}_i$ и $\overline{r}_{i + 1}$, где $\begin{pmatrix}\overline{b}_j \\ \overline{b}_j\end{pmatrix}$ обозначает обозначает комбинированный вектор состоящий из двух копий вектора $\overline{b}_j$, а выражение $\begin{pmatrix}\overline{a}_{ij} \\ \overline{a}_{i + 1,j}\end{pmatrix}$ обозначает вектор, первые 8 элементов которого равны $a_{ij}$, а остальные 8 элементов -- $a_{i + 1,j}$ ($\circ$ -- произведение Адамара, или поэлементное произведение векторов).
Заметим, что получающийся по данной формуле комбинированный вектор $\begin{pmatrix}\overline{r}_i \\ \overline{r}_{i + 1}\end{pmatrix}$ расположен в памяти последовательно, и записывать его в память можно с помощью интринсика \texttt{\_mm512\_store\_ps}.
При этом предполагаем, что значение $i$ четно, то есть вектор $\begin{pmatrix}\overline{r}_i \\ \overline{r}_{i + 1}\end{pmatrix}$ выровнен в памяти должным образом.
Другие комбинированные векторы в данном выражении получаются с помощью инструкции perm (интринсик \texttt{\_mm512\_permutexvar\_ps}), примененной к соответствующим загруженным соседним строкам матриц a и b.
Таким образом, при реализации вышеприведенной формулы не требуется использование медленных инструкций gather/scatter, так как столбцы матриц не читаются и не записываются (работа ведется только со строками). После того, как требуемые векторы сформированы, нужно выполнить их попарное поэлементное перемножение, после чего сложить в один вектор (8 операций поэлементного умножения, 7 операций сложения).
Эти действия можно выполнить, используя комбинированные операции fmadd.

\begin{figure}[ht]
	\centering
		\includegraphics[width=1.00\textwidth]{./pics/text_4_spec_matr/fmadd.pdf}
	\caption{Схема вычисления двух соседних строк результирующей матрицы путем последовательного сложения попарно перемноженных векторов}
	\label{fig:text_4_spec_matr_fmadd}
\end{figure}

Для вычисления значения $\begin{pmatrix}\overline{r}_i \\ \overline{r}_{i + 1}\end{pmatrix}$ потребуется 8 векторных операций (1 операция mul и 7 операций fmadd) (см. рис. 2).
На данном рисунке для удобства представлена схема последовательного сложения перемноженных векторов. Возможен также другой вариант, реализующий вычисление $\begin{pmatrix}\overline{r}_i \\ \overline{r}_{i + 1}\end{pmatrix}$ с помощью балансировки дерева потока данных.
Такой вариант потребует 4 операций mul, 4 операций fmadd и 3 операций add.
В данном контексте вычислений длина критической цепочки не влияет на время работы кода, поэтому мы оставляем вариант с минимальным количеством инструкций (меньше 8 инструкций задействовать невозможно, так как нужно выполнить по крайней мере 8 операций умножения).

\subsubsection{Реализация}

Приведем функцию перемножения двух матриц размера 8x8, механизм которой был рассмотрен в предыдущем разделе.
Для реализации выполним полную загрузку обеих матриц a и b.
На это потребуется 8 операций обращения в память, так как за одну операцию загружаются две соседние строки матрицы.
Далее требуется сформировать 8 векторов вида $\begin{pmatrix}\overline{b}_j \\ \overline{b}_j\end{pmatrix}$, для чего потребуется еще 8 операций perm (для каждой пары загруженных строк матрицы b нужно выполнить дублирование первой строки и дублирование второй строки).
Формирование векторов индексов для операций perm не требует вычислительного времени, так как индексы являются статическими и вычисляются на этапе компиляции.

После подготовки всех необходимых данных выполняется вычисление значений результирующей матрицы.
Приведенный ниже блок операций (макрос BLOCK) осуществляет вычисление двух соседних строк результирующей матрицы.
Реализация блока состоит из 8 операций perm, 1 операции mul и 7 операций fmadd, кроме того выполняется одна операция записи в память.
Всего выполняется четыре таких блока, что в сумме и с учетом операций подготовки данных приводит к следующему итогу: 8 простых операций чтения из памяти, 40 операций perm, 4 операции mul, 28 операций fmadd, 4 простые операции записи в память.
Итоговый код (без отображения некоторых повторяющихся участков) приведен на листинге ниже.

\begin{lstlisting}[caption={caption},label={label}]
void mul_8x8_opt(float * __restrict a, float * __b, float * __restrict r)
{
    ........................................
    __m512i ind_df = _mm512_set_epi32( 7,  6,  5,  4,  3,  2, 1, 0,
                                       7,  6,  5,  4,  3,  2, 1, 0);
    __m512i ind_ds = _mm512_set_epi32(15, 14, 13, 12, 11, 10, 9, 8,
                                      15, 14, 13, 12, 11, 10, 9, 8);

    __m512 b0 = LD(&b[0]);
    __m512 b1 = _mm512_permutexvar_ps(ind_ds, b0);
    b0 = _mm512_permutexvar_ps(ind_df, b0);
    ........................................
    __m512 b6 = LD(&b[6 * V8]);
    __m512 b7 = _mm512_permutexvar_ps(ind_ds, b6);
    b6 = _mm512_permutexvar_ps(ind_df, b6);

    __m512 a0 = LD(&a[0]);
    ........................................
    __m512 a6 = LD(&a[6 * V8]);

    __m512i ind_0 = _mm512_set_epi32( 8,  8,  8,  8,  8,  8,  8,  8,
                                      0,  0,  0,  0,  0,  0,  0,  0);
    ........................................
    __m512i ind_7 = _mm512_set_epi32(15, 15, 15, 15, 15, 15, 15, 15,
                                      7,  7,  7,  7,  7,  7,  7,  7);

#define BLOCK(N, A)                           \
    ST(&r[N * V8],                            \
      FMADD(PERMXV(ind_0, A), b0,             \
        FMADD(PERMXV(ind_1, A), b1,           \
          FMADD(PERMXV(ind_2, A), b2,         \
            FMADD(PERMXV(ind_3, A), b3,       \
              FMADD(PERMXV(ind_4, A), b4,     \
                FMADD(PERMXV(ind_5, A), b5,   \
                  FMADD(PERMXV(ind_6, A), b6, \
                    MUL(PERMXV(ind_7, A), b7)))))))));

    BLOCK(0, a0);
    BLOCK(2, a2);
    BLOCK(4, a4);
    BLOCK(6, a6);

#undef BLOCK

}
\end{lstlisting}

Заметим, что 28 векторных операций fmadd и 4 векторные операции mul соответствуют (28 * 2 + 4) * 16 = 960 скалярным операциям, что в точности совпадает с количеством скалярных операций, требуемых для выполнения перемножения двух матриц размера 8x8.
Таким образом, в предложенной реализации нет лишних арифметических операций, и результат каждой выполненной операции влияет на конечный результат.

При реализации перемножения матриц размера 7x7, 6x6, 5x5 удаляются заведомо лишние векторные операции (например, умножение на вектор, все элементы которого равны нулю), однако все равно остаются элементы векторов, обработка которых избыточна, что приводит к снижению эффективности векторизации в этих случаях.
Ниже приведем таблицу с точным подсчетом количества скалярных операций для невекторизованных функций и количества векторных операций для их векторизованных аналогов (см. табл. 1).

\begin{center}
\begin{tabular}{ | c | c | c | }
  \hline
  \ & Невекторизованный вариант & Векторизованный вариант \\ \hline\hline
  8x8 & \makecell{512 mul, 448 add \\ 960 арифметических операций} & \makecell{4 mul, 28 fmadd, 40 perm \\ 960 арифметических операций} \\ \hline
  7x7 & \makecell{343 mul, 294 add \\ 637 арифметических операций} & \makecell{4 mul, 24 fmadd, 35 perm \\ 832 арифметические операции} \\ \hline
  6x6 & \makecell{216 mul, 180 add \\ 396 арифметических операций} & \makecell{3 mul, 15 fmadd, 24 perm \\ 528 арифметических операций} \\ \hline
  5x5 & \makecell{125 mul, 100 add \\ 225 арифметических операций} & \makecell{3 mul, 12 fmadd, 20 perm \\ 432 арифметические операции}
 \\ \hline
\end{tabular}
\end{center}

Из таблицы 1 видно, что с понижением размерности перемножаемых матриц возрастает избыточность вычислений (для размера 5x5 данная избыточность почти достигает двукратного размера), что сказывается отрицательно на эффективности векторизации.

\subsubsection{Полученные результаты}

Описанные в статье подходы к векторизации перемножения матриц были проверены на суперкомпьютере МВС-10П МСЦ РАН, на его вычислительном сегменте, содержащем микропроцессоры Intel Xeon Phi 7290 KNL.
Были рассмотрены 4 функции: \texttt{mul\_8x8}, \texttt{mul\_7x7}, \texttt{mul\_6x6}, \texttt{mul\_5x5}, выполняющие перемножение матриц соответствующих размеров.
Для каждой функции были рассмотрены 3 варианта реализации. В качестве первого варианта был использован старый способ векторизации с параллельным вычислением сумм элементов векторов (обозначен VECT OLD), в качестве второго варианта было взято прямое ручное вычисление каждого элемента результирующей матрицы, в котором все циклы были удалены и для каждого элемента путем многократного копирования был написан скалярный код (обозначен FULL UNROLL), в качестве третьего варианта взят рассмотренный подход, основанный на обращениях только к строкам матриц и использовании комбинированных операций fmadd (обозначен VECT NEW).

\begin{figure}[ht]
	\centering
		\includegraphics[width=1.00\textwidth]{./pics/text_4_spec_matr/res.png}
	\caption{Ускорение функций \texttt{mul\_8x8}, \texttt{mul\_7x7}, \texttt{mul\_6x6}, \texttt{mul\_5x5} после их оптимизации с помощью подходов OLD VECT, FULL UNROLL, NEW VECT}
	\label{fig:text_4_spec_matr_res}
\end{figure}

На рис. 3 показаны результаты тестирования описанных подходов на машине.
Из рисунка следует, что OLD VECT оказался наименее эффективным подходом, его применение даже менее выгодно, чем прямое написание скалярного кода.
Для матриц размера 5x5 данный метод оптимизации вовсе приводит к замедлению оригинальной неоптимизированной версии функции. Метод NEW VECT демонстрирует наилучшие результаты из описанных подходов, на матрицах размера 8x8 продемонстрировано ускорение почти в 6 раз по сравнению с оригинальным кодом. При понижении размерности матриц эффективность векторизации несколько снижается, однако даже для матриц размера 5x5 наблюдается ускорение примерно в 2,5 раза, что позволяет внедрять данный метод в промышленный код.
